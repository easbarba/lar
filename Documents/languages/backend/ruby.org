#+TILE: Ruby Language - Annotations

* Summary
  :PROPERTIES:
  :TOC:      :include all :depth 3 :ignore this
  :END:
  :CONTENTS:
  - [[#progress][Progress]]
    - [[#books][Books]]
    - [[#sloc][SLOC]]
  - [[#packages][Packages]]
    - [[#gem][gem]]
    - [[#bundle][bundle]]
      - [[#outdated][outdated]]
      - [[#gem][gem]]
      - [[#install][install]]
      - [[#update][update]]
    - [[#irb][irb]]
      - [[#cli][cli]]
      - [[#inside][inside]]
    - [[#rspec][rspec]]
    - [[#unit-test][unit test]]
    - [[#pry][pry]]
  - [[#features][Features]]
    - [[#project-structure][project structure]]
    - [[#system-errors][System Errors]]
      - [[#usage][usage]]
    - [[#exceptions][exceptions]]
      - [[#errors][Errors]]
      - [[#usage][usage]]
    - [[#writable-object-attribute][writable object attribute]]
    - [[#multithreading][Multithreading]]
      - [[#usage][usage]]
    - [[#modules][modules]]
    - [[#continuation][continuation]]
    - [[#fibers][Fibers]]
      - [[#errors][errors]]
      - [[#usage][usage]]
    - [[#delimited-input][delimited input]]
    - [[#rake][rake]]
      - [[#usage][usage]]
    - [[#gem][gem]]
    - [[#variables][Variables]]
      - [[#class-variables][class variables]]
      - [[#global-variables][global variables]]
    - [[#self][self]]
    - [[#commentary][commentary]]
    - [[#defined][defined?]]
    - [[#iterators][iterators]]
    - [[#block-local-variables][block-local variables]]
    - [[#loops][loops]]
    - [[#statement-modifiers][statement modifiers]]
    - [[#comparison][comparison]]
    - [[#conditional][conditional]]
    - [[#class][class]]
      - [[#class][class]]
    - [[#append-][append <<]]
    - [[#blocks][blocks]]
    - [[#lambda][lambda]]
      - [[#how][How]]
      - [[#usage][Usage]]
    - [[#methods][methods]]
    - [[#yield][yield]]
    - [[#procs][procs]]
    - [[#operators][operators]]
    - [[#enumerable][enumerable]]
    - [[#enumerator][enumerator]]
      - [[#lazy][lazy]]
      - [[#each_car][each_car]]
      - [[#each][each]]
      - [[#to_enumenum_for][to_enum/enum_for]]
    - [[#inject][inject]]
    - [[#select][select]]
    - [[#succ][succ]]
    - [[#collect][collect]]
    - [[#freeze][freeze]]
    - [[#dup][dup]]
    - [[#dig][dig]]
    - [[#fetch][fetch]]
    - [[#tap][tap]]
    - [[#map][map]]
    - [[#pluck][pluck]]
    - [[#quoting][Quoting]]
    - [[#here-documents][here documents]]
    - [[#proc][proc]]
    - [[#do-end-as-param][do end as param]]
    - [[#array][array]]
    - [[#datetime][date/time]]
    - [[#lambda][lambda]]
    - [[#begin-rescue][begin rescue]]
    - [[#hash][hash]]
    - [[#range][range]]
    - [[#sets][sets]]
    - [[#gsub][gsub]]
    - [[#find][find]]
    - [[#map][map]]
    - [[#each_slice][each_slice]]
    - [[#lazy][lazy]]
    - [[#with_index][with_index]]
    - [[#enum_for][enum_for]]
    - [[#more][more]]
    - [[#concepts][Concepts]]
      - [[#iterator][Iterator]]
      - [[#methods][Methods]]
      - [[#enumerator][Enumerator]]
    - [[#instructions][Instructions]]
      - [[#rbenv][Rbenv]]
      - [[#misc][misc]]
  - [[#toolings][Toolings]]
  - [[#videos][Videos]]
  - [[#tests][Tests]]
    - [[#rspec][RSpec]]
    - [[#unit][Unit]]
  :END:
* Progress
** Books
| Books                            | Chapter                            | late                                    |
|----------------------------------+------------------------------------+-----------------------------------------|
| Programming Ruby                 | 2                                  | Inside the Object Model                 |
| Metaprogramming ruby             | 2                                  | Monday: The Object Mode                 |
| Effective Testing - RSpec3       | Testing in Isolation: Unit Specs   | Handling Failure                        |
| Confident Ruby                   | Collecting input                   | 3.8 Define conversion functions         |
| Closure in Ruby                  | The Power of Procs and Lambdas     | Implementing Lax                        |
| Design Patterns in Ruby          | Composite                          |                                         |
| Practical Object-Oriented Design | Sharing Role Behavior with Modules |                                         |
| Eloquent Ruby                    | Embrace Dynamic Typing             | Shorter Programs, But Not               |
| The Well Grounded Rubyist        | Functional                         | 16.2.1 Object#freeze and Object#frozen? |

** SLOC
| Project    | folder | file           | @ |
|------------+--------+----------------+---|
| ruby       | cgi    | cookie.rb      |   |
| rake       |        | application.rb |   |
| solargraph |        | api_map.rb     |   |

* Features
** Classes
- :: is Ruby’s namespace resolution operator.
- Math::PI - access Math PI variable
- Math.sin(Math::PI/6.0) - access Math sin method
- Names of classes and modules are just constants.
- can nest classes and modules inside other classes and modules to any depth

*** usage
#+begin_src ruby
# frozen_string_literal: true

[].methods.grep /^re/ # finds methods begins with re

    require 'pathname'

    # Class Description
    class Meh # Class name in Camel Case
      OUCH = 'asdasd' # 1
      attr_reader :lo, :fi # 2

      # static method
      def self.from_file(file_name) # 3
	new(File.readlines(file_name))
      end

      def initialize(lo, fi) # 4
	@alpha = OUCH
	@lo = lo #
	@fi = fi #
      end

      private_class_method :new

      private

      def alfa # instance method
	@localVar = 1
      end

      def use_local_var # instance method
	@localVar
      end

      def self.zeta #
      end
    end

    Eija = Class.new #

    def Eija.beta # singleton
    end


    # superclass

    class Parent
    end
    class Child < Parent
    end

    Child.superclass # => Parent

    #
    meth.owner
    #
#+end_src

*** Class methods
- Class methods are singleton methods defined on objects of class `Class`.
- a method defined as a singleton method of a class object can 2also be called on subclasses of that class.

#+begin_src ruby
class C
end

def C.a_class_method
  puts "Singleton method defined on C"
end

C.a_class_method # Singleton method defined on C
#+end_src

*** include
The include directive includes all methods from the given module and make them
available as instance methods in your class

#+begin_src ruby
module Greeting
  def hello
    puts 'Hello from module'
  end
end

class MyClass
  include Greeting
end

my_class = MyClass.new
my_class.hello # => 'Hello from module'

MyClass.ancestors # [MyClass, Greeting, Object, Kernel, BasicObject]

#+end_src

*** prepend
- The extend directive includes all methods from the given module and make them
  available as class methods in your class
#+begin_src ruby
module Greeting
  def hello
    puts 'Hello from module'
  end
end

class MyClass
  extend Greeting
end

MyClass.hello # => 'Hello from module'

MyClass.singleton_class.ancestors # [#<Class:MyClass>, Greeting, #<Class:Object>, #<Class:BasicObject>, Class, Module, Object, Kernel, BasicObject
#+end_src
*** extend
- the module is placed right after your class, but when you use prepend is
  prepended, which means that it is set before your class:
#+begin_src ruby
module Greeting
  def hello
    puts "Hello from module"
    super
  end
end

class MyClass
  prepend Greeting

  def hello
    puts "Hello from class"
  end
end

MyClass.new.hello
# => "Hello from module"
# => "Hello from class"

MyClass.ancestors # => [Greeting, MyClass, Object, Kernel, BasicObject]


#+end_src
*** super
   #+begin_src ruby
   def x(y,z)
     super # passes all the parameters from the current method and hands the parameters to the method from the base class
     super() # calls the method without any arguments.
   end
   #+end_src
*** Singleton Classes
- Sometimes called meta-classes
- The Ruby standard library includes an implementation of the singleton pattern *require 'singleton'*
**** Methods
***** #singleton_class
Refers directly to the singleton class of an object
#+begin_src ruby
string = "a string"
string.singleton_class.ancestors # => [#<Class:#<String:0x0000563fb8797270>>, String, Comparable, Object,Kernel, BasicObject]
#+end_src
**** Singleton methods
** Objects
*** methods query
Returns a list of the names of public and protected methods of obj.
#+begin_src ruby
string = "aaa"
string.methods.grep(/case/).sort
#+end_src
*** initialize
#+begin_src ruby
class Point
  def initialize(x, y)
    @x = x
    @y = y
  end
end

Meh.new('foo', 'bar') #  #<Meh:0x0000000003a33d80 @x="bar", @y="foo">

#+end_src

Default/Optional arguments

#+begin_src ruby

class Meh
  def initialize(x='bar', y='foo')
    @x = x
    @y = y
  end
end

Meh.new # #<Meh:0x0000000003a33d80 @x="bar", @y="foo">
#+end_src
*** attributes
**** attr_accessor
**** attr_writer
**** attr_reader

*** private_methods / protected_methods
private and protected method names

#+begin_src ruby
Object.new.private_methods # 77
Object.new.protected_methods # 0
#+end_src
*** instance variables
*** freeze
- make objects (nearly) immutable

**** Add the following line to the top of any individual file:
# frozen_string_literal: true

**** Run your programs on the command line with a specific instruction.
This will make every string in your program frozen by default:

$ ruby --enable-frozen-string-literal my_program.rb

#+begin_src ruby
   person1.freeze # prevent modifications to the object
#+end_src
*** object_id
- Returns an integer identifier for obj.
- The same number will be returned on all calls to object_id for a given object, and no two active objects will share an id.

*** self
   - is a keyword
   - It does this to allow the method chaining in the line scores << 10 << 20 << 40 . Because each call to << returns the scores object, you can then call << again, passing in a new score.

     #+begin_src ruby

     class tea
       def self.drink () # Class-Level method (static)
	 puts 'drinking'
       end

       def meh
	 puts self # refers to tea class
       end

       def builder

	 self # return class
       end
     end
     #+end_src
*** methods
   default values, splat args (described later on page 120), keyword args, and a block parameter
#+begin_src ruby
def splating(*rest)
  puts rest.each { |x| puts }
end

def split_apart(first, *, last) # get first and last args, ignore middle ones
end

#+end_src
**** capture methods
#+begin_src ruby

class C
  def talk
    puts "Method-grabbing test!"
  end
end

c = C.new

meth = c.method(:talk)
meth.owner
meth.call # to exeute
meth[]
meth.()
#+end_src
**** unbind methods
unbind the method from its object and then bind it to another object, as long as
that other object is of the same class as the original object
#+begin_src ruby
class D < C
end

d = D.new
unbound = meth.unbind
unbound.bind(d).call
#+end_src

*** dup
   #+begin_src ruby
   person1 = "Tim"
   person2 = person1.dup # not aliasing person1
   #+end_src
*** ancestor
An array of ancestors—essentially, the method-lookup path for instances of this class.
*** statement modifiers
   if and unless Modifiers
   #+begin_src ruby
   puts "a = #{a}" if $DEBUG
   print total unless total.zero?
   a *= 2 while a < 100
   a -= 10 until a < 10
   #+end_src
** Modules
   #+begin_src ruby

   module A
     module_function

     def foo
     end
   end

   module A
     module SubA
       def bar
       end
     end
   end


   A::foo
   A::SubA:bar

   a = Module.new

   a.class_eval do
     remove_method
     method_defined?

     attr_reader name
     alias_method x,e
   end

   #+end_src

*** Mixin

** Types
*** String
**** methods
***** new
#+begin_src ruby
String.new("an unfrozen string")
#+end_src
***** concat
#+begin_src ruby
str = ""

str.concat("a")
str.concat("a")

str
# "aa"
#+end_src

***** dup
****** freeze
******* unfreezen
unary plus operator
#+begin_src ruby
str = "frozen!"
str.frozen? # true

unfrozen_str = +str
unfrozen_str.frozen? # false
#+end_src
***** each_byte
***** scan
#+begin_src ruby
s = 'Peter Piper picked a peck of pickled peppers'
s.scan(/[Pp]\w*/) {|word| puts("The word is #{word}")}
#+end_src
**** interpolation
#+begin_src ruby
age  = 33
name = "Jesus"

"Hello, my name is #{name} & I'm #{age} years old."
#+end_src
**** here documents
- <<-, minus sign, which the terminator can be indented from the margin.

   #+begin_src ruby
   <<EOL # double quote document
      \n
   #{Time.now}
   EOL

   <<EOL.to_i * 10
   EOL

   <<'EOL' # single quote document
      \n
   #{Time.now}
   EOL

   <<-EOL
   EOL

   <<~EOL
   EOL

   [1,2, <<EO asdasd EO]

   a(false, <<EO asd... EO)
   #+end_src
**** quoting
   %char{text}
   #+begin_src ruby
   a = %q(a b c d)

   b = %Q(a b c)
   #+end_src

**** examples
#+begin_src ruby
"Test" + "Test" #TestTest
"test".capitalize #Test
"Test".downcase #test
"Test".chop #Tes
"Test".next #Tesu
"Test".reverse #tseT
"Test".sum #416
"Test".swapcase #tEST
"Test".upcase #TEST
"Test".upcase.reverse #TSET
"Test".upcase.reverse.next
"Test".ord
"Test".chr
"xyz".scan(/./) { |letter| puts letter }

# SUBSTITUTION

"".sub('i', '') # only does one substitution at a time, on the first instance of the text to match
"".gsub('i', '') #  whereas gsub does multiple substitutions at once
#+end_src

*** Array
- index collection

**** intersection (&)
**** union (|)
**** difference (-)
**** queue
#+begin_src ruby
queue = []

queue.unshift "apple"
queue.unshift "orange"
queue.unshift "banana"

# ["banana", "orange", "apple]"

queue.pop
# "apple"

queue.pop
# "orange"
#+end_src
**** new
#+begin_src ruby

Array.new(4) # [nil, nil, nil, nil]
Array.new(4) { |x| x + 1 } # [1, 2, 3, 4]

#+end_src
**** Kernel#Array
- More forgiving than .to_a

#+begin_src ruby
Array 1 # [1]
#+end_src

**** examples
   #+begin_src ruby
   h = { a: 100, b: 20 }
   h.delete_if { |key, value| value < 25 }
   h.delete(:a)
   #+end_src

   #+begin_src ruby
   # creation
   a = [1, ["a", "b"], 4]
   a = Array.new(1,2)
   a = arr = %w( Hey!\tIt is now -#{Time.now}- )


   # indexing
   arr[1][0]
   [1,2][0]
   arr.dig(3,0) value_at, a[2,3] = ..
				   a[2..3]
   a.slice()
   a.[]=(0, "first")
   a.[](2)
   a = %w(a b c)
   a= %W({a} b c)
   x.to_ary
   x.to_arr
   Array()
   def string.to_arr
   end
   a.unshift(0)
   a.push(1,2,3)
   a << 5
   a.pop
   a.shift
   a.concat
   a.replace([1,2,3])
   a.flatten
   a.reverse
   a.join(" , ")
   a = *
       a.uniq
   a.compact
   a.size
   a.empty
   a.include?
   a.first
   a.first[<num>]
   a.last
   a.sample # return
   a.count(1)
   #+end_src
   [[file:path]]
**** push
**** pop
**** access
**** find
**** delete
**** max_by
**** compact
**** array
#+begin_src ruby
a = Array.new
# shallow copy
b = Array.new [1,2,3]
#+end_src
**** reverse_each
**** each_index
*** Queue
- thread-safe, blocking.
- If the queue is empty, calling pop will put your current thread to sleep &
  wait until something is added to the queue.
- passing true to avoid blocking


#+begin_src ruby
que = Queue.new

que << 1
que << 2
que << 3

que.pop # 1
que.pop # 2

que.pop(true)
#+end_src
*** Sized Queue
- push (same as <<) operation will suspend the current thread until an item is taken off the queue.
- same as a regular queue but with a size limit.
- raise an exception instead, passing true as an argument to push

#+begin_src ruby
que = SizedQueue.new(5)
que.push(:bacon)
que.push(:bacon, true) # raises ThreadError: queue full
#+end_src
*** Sets
   #+begin_src ruby
   s = Set.new(array)
   s = Set.new(names) {name name.upcase }
   s << 5
   s.add 5
   s.delete(1)
   s.intersection|&| x
   s.union x
   s + x
   s.difference x
   s - x
   s ^ x
   s.merge [2]
   s.subset? b
   s.superset? b
   s.proper_subset? x
   s.proper_superset? x
   #+end_src
*** Hash
- keys must be comparable
- rehash force the hash to be reindexed whenever a key has changed
- index collection
**** methods
***** store
***** acess
***** delete
***** each_key
***** each_value
***** find(<value>)
***** more
#+begin_src ruby
# Strings keys
h = { "one" => 1, "two" => 2 }

# Symbols keys
h = { one: 1, two: 2 }

# Empty Hash
h = Hash.new

# default value is zero
h = Hash.new(0)

# Hash alternative(old) version
h = Hash[1, "one", 2, "two"]


# get value
h["one"] = 1
h[:one]

h.rehash # force the hash to be reindexed

h.[]=("New York", "NY")
h.store("New York", "NY")
a.update(b)
a.merge(b)
h.select {k,vk > 1 } !
h.reject {  k,v  k > 1 } !
h.reject! {  k,v  k > 1 }
h = { street: "127th Street", apt: nil }.compact!
h = { street: "127th Street", apt: nil }.compact!
h.invert
h.clear
h = {...}.replace({...})
h.key?
h.empty?
#+end_src

** Range
|     |                                      |
|-----+--------------------------------------|
| ..  | inclusive                            |
| ... | exclusive, excludes its last element |

   #+begin_src ruby
   # create a new range object
   r = 1..2

   # include all elements
   r =  1..99

   # exclude last element
   r = 1...199

   # verbose object creation
   r = Range.new(1,100)
   r = Range.new(1,100, true)

   # methods
   r.cover? 2
   r.include? 3
   r.max
   r.reject {}
   r.inject {}

   # range of object need to return the next object `succ` and be comparable <=>

   # ranges as conditions
   while line = gets
     puts line if line =~ /start/ .. line =~ /end/
   end

   # ranges as intervals
   (1..10) === 5   # => true
   (1..10) === 15  # => false





   #+end_src

*** Symbols
- undeclared constant names guaranteed to be unique.
#+begin_src ruby
:Object
:my_variable
:"Ruby rules"
a = "cat"
:'catsup' # => :catsup
:"#{a}sup" # => :catsup
:'#{a}sup' # => :"\#{a}sup"
#+end_src
** Functional
*** concepts
**** immutability
nope
**** method chaining
#+begin_src ruby
"joe".upcase.reverse # "EOJ"
#+end_src

*** map
   #+begin_src ruby
   a.map { |x| x.uppercase}
   a.map! { |x| x.uppercase}
   #+end_src
*** proc
   - if the last parameter in a method definition is prefixed with an ampersand,
     any associated block is converted to a Proc object, and that object is
     assigned to the parameter. This allows you to store the block for use
     later.

#+begin_src ruby
p = Proc.new { puts "yay" }
p = proc { puts "yay" }
p.call

def x(&block)
  block.call
end

x(&p) # => yay
x(p.to_proc) # => yay

y = Proc.new {|y| puts y.upcase }
%w{ David Black }.each(&y) # => DAVID BLACK

class Symbol
  def to_proc
    puts "In the new Symbol#to_proc!"
    Proc.new {|obj| obj.public_send(self) }
  end
end

def multiply_by(m)
  Proc.new {|x| puts x * m }
end
mult = multiply_by(10)
mult.call(12

   def pass_in_block(asdf, &block)
   end

   multiple_of_three = -> n { (n % 3).zero? }
   palindrome = -> n { n = n.to_s; n == n.reverse }

   p Integer
       .all
       .select(&multiple_of_three)
       .select(&palindrome)
       .first(10)

   a = Proc.new

   def initialize(name, &block) # initialize can receive proc object

     tc = TaxCalculator.new("Sales tax") {|amt| amt * 0.075 }
     tc.get_tax(100) # => "Sales tax on 100 = 7.5"

#+end_src
*** lambda
**** How
    #+begin_src ruby
    lambda { |params| ... } # form 1

    -> params { ... }  # form 2
    #+end_src
**** Usage
#+begin_src ruby
proc1 = -> arg { puts "In proc1 with #{arg}" }
proc1.call "ant"

def n_times(thing)
  lambda {|n| thing * n }
end

p1 = n_times(23)
p1.call(3) # => 69
#+end_src


 #+begin_src ruby
 l = -> { xx; aa }
 l = lambda do
   yield xx
 end
 #+end_src

sugar syntax:
- dot operator as shortcut. note: better avoid this one
- square brackets too

#+begin_src ruby

l = -> (x) { p x }
l.('meh')
l['meh']

#+end_src

*** curry
**** desc
Returns a curried proc based on the method. When the proc is called with a
number of arguments that is lower than the method’s arity, then another curried
proc is returned. Only when enough arguments have been supplied to satisfy the
method signature, will the method actually be called.

The optional arity argument should be supplied when currying methods with
variable arguments to determine how many arguments are needed before the method
is called.
**** usage

#+begin_src ruby


#+end_src

**** optional arity argument

When called with this argument, the curried object will only be evaluated when
the given number of arguments has been supplied:

#+begin_src ruby

sum_all = -> (*nums) { nums.reduce(:+) }
sum_all.curry.(1,2,3) # 6
sum_at_least_four = sum_all.curry(4)
sum1 = sum_at_least_four.(3,4) # #<Proc:0x000055d2f90867a0 (lambda)>
sum2 = sum1.(5) # #<Proc:0x000055d2f90b4948 (lambda)>
sum3 = sum2.(7) # 19

#+end_src

**** currying methods

#+begin_src ruby

def add(a, b, c) ; a + b + c ; end # :add

fun = method(:add).curry # #<Proc:0x000055f71cb45758 (lambda)>
fun.(1,2,3) # 6

#+end_src

** Logs
*** Logger
- 1st parameter is where to save log messages
- 2nd parameter is how many log files you want to keep (log rotation)
- the last parameter is the maximum file size.
- levels: DEBUG INFO WARN ERROR FATAL UNKNOWN
- different levels helps you filter your log file

#+begin_src ruby
Logger.new(<file>, <how many log files>, <maximum file size>)
#+end_src


#+begin_src ruby
logger = Logger.new("my_log")

logger = Logger.new(STDOUT) #  display messages on the terminal

logger.info("I'm reading a RubyGuide about logging!")

logger.formatter = proc { |severity, datetime, progname, msg| "#{severity}, #{datetime}, #{msg}\n" } # DEBUG, 2019-08-08 19:39:01 +0200, testing
#+end_src
** Kernel
*** alias
#+begin_src ruby
class String
  alias __old_reverse__ reverse
end

class String
  alias_method :__old_reverse__, :reverse
end

#+end_src
*** autoload
#+begin_src ruby
autoload :SharedContext, 'rspec/core/shared_context'
#+end_src
*** grep

** Methods
*** Parameters
**** do end as param
   #+begin_src ruby
   x = (do  1 + 2 end)
   x = (do 'a' + 'b' end).join(',')
   #+end_src
**** takes no keywords
#+begin_src ruby
def x(**nil)
end
#+end_src
**** argument forwarding
#+begin_src ruby
def x(...)
end
#+end_src
*** name=
*** name

** Pattern Matching
#+begin_src ruby
[1,2,3] in [a,b,c] # true
[1,2,3] in [a]     # false

{ a: 1, b: 2, c: [] } in { a: a, b: b, c: [] } # true
p a # 1
#+end_src
** Project structure
   #+begin_src ruby
   anagram/    <- top-level
   bin/      <- command-line interface goes here
   lib/      <- three library files go here
   test/     <- test files go here
   #+end_src
** Errors
*** Exceptions
   - class *Exception*
   - Custom exceptions subclasses of StandardError or its children.
   - Exception has an associated message string and a stack backtrace.
   - Custom exceptions can add extra information
   - rescue matches thrown Exception and use it. Similar to case statement
   - rescue clause with no parameter list, the parameter defaults to StandardError .
   - rescue clause can be arbitrary expressions (including method calls) that return an Exception class.
**** Errors
    - StandardError
    -
**** usage
    #+begin_src ruby

    # Exception skeleton

    f = File.open("/a/file")
    begin
    # .....
    rescue Exception
      if @esmtp then
	@esmtp = false
	retry # repeat the entire begin / end block
      else
	raise # reraise the exception. FAIL is similar
      end
    else # after RESCUE and before any ENSURE, is executed only if no exceptions are raised by the main body of code.
      puts "Congratulations-- no errors!"
    ensure
      f.close
    end

    # At the end of each rescue clause, you can give Ruby the name
    # of a local variable to receive the matched exception.
    begin
      eval string
    rescue SyntaxError, NameError => boom
      print "String doesn't compile: " + boom
    rescue StandardError => bang
      print "Error running script: " + bang
    end

    # reraises the current exception (or a RuntimeError if there is no current exception).
    # This is used in exception handlers that intercept an exception before passing it on.
    raise

    # Creates a new RuntimeError exception, setting its message to the given string.
    raise "bad mp3 encoding" #

    # first argument to create an exception and then sets the associated
    # message to the second argument and the stack trace to the third argument.
    raise InterfaceException, "Keyboard failure", caller

    raise

    raise "Missing name" if name.nil?

    if i >= names.size
      raise IndexError, "#{i} >= size (#{names.size})"
    end

    raise ArgumentError, "Name too big", caller

    # removes two routines from the backtrace
    # by passing only a subset of the call stack to the new exception:
    raise ArgumentError, "Name too big", caller[1..-1]
    #+end_src
**** begin rescue
   #+begin_src ruby
   begin
     puts 'I am before the raise.'
     raise 'An error has occured.'
     puts 'I am after the raise.'
   rescue
     puts 'I am rescued.'
   end
   #+end_src
*** Trace
**** caller
The caller method provides an array of strings. Each string represents one step in the stack trace:
#+begin_src ruby
def x
  p caller
  end
#+end_src
*** System Errors
   - SystemCallError
   - subclasses are defined in a module called Errno
**** usage
    #+begin_src ruby
    Errno::EAGAIN
    Errno::EIO
    Errno::EPERM

    Errno::EAGAIN::Errno # => 35, same error number as EWOULDBLOCK, can be interchangeable
    Errno::EPERM::Errno # => 1
    Errno::EWOULDBLOCK::Errno # => 35
    #+end_src
** Parallel / Concurrency
*** Thread
- If the program ends while one or more threads are running, those threads are killed.
- can be asleep or awake, and alive or dead.

#+begin_src ruby
x = Thread.new { puts "What's the big deal" }
x.value
x.join
x.exit

Thread.kill(x)

threads = []
threads << Thread.new { puts "What's the big deal" }
threads << Thread.new { 3.times { puts "Threads are fun!" } }
threads.each { |thr| thr.join }


t = Thread.new do
  (0..2).each do |n|
    begin
      File.open("part0#{n}") do |f|
        text << f.readlines
      end
    rescue Errno::ENOENT
      puts "Message from
thread: Failed on n=#{n}"
      Thread.exit
    end
  end
end
t.join

Thread.stop
t.status
t.stop?
t.alive
t.wakeup
t.join
t.inspect

t.current[:message] = "Holla"

t.fetch(:message)
t.fetch(:msg, "ola")
#+end_src
*** Fibers
- no require
- resume
- yield
- require: requiring `fiber library` gives additional `transfer` methods
**** errors
    - FiberError: calling resume after last fiber returned `nil`
**** usage
#+begin_src ruby

twos = Fiber.new do
  num = 2
  loop do
	Fiber.yield(num) unless num % 3 == 0 # returning control to the calling context
	num += 2
  end
end

10.times { print twos.resume, " " }
#+end_src

   #+begin_src ruby
   f = Fiber.new do
     x = 0
     loop do
       Fiber.yield x
       x -= 1
     end
   end
   #+end_src
*** Mutex
** delimited input
   #+begin_src ruby
   # %q - Single-quoted string
   %q{\a and #{1+2} are literal}

   # %Q, % - Double-quoted string
   %Q{\a and #{1+2} are expanded}

   # %w, %W - Array of strings
   %w[ one two three ]

   # %i, %I -  Array of symbols
   %i[ one two three ]

   # %r - Regular expression pattern
   %r{cat|dog}

   # %s - A symbol
   %s!a symbol!

   # %x, `` - Shell command
   %x(df -h)

   #+end_src
** Variables
*** class variables
- available throughout a class or module body
- must be initialized before use
- is shared among all instances of a class and is available within the class itself.

#+begin_src ruby
class Meh
  @@foo = 'Bar'

  def value
    @@foo
  end
end
#+end_src

*** instance variables
#+begin_src ruby
class Meh
  @foo = 'Bar'

  def to_s
    @foo
  end
end
#+end_src
*** global variables
- available throughout a program.
- references to it returns the same object.
- referencing an uninitialized global variable returns nil.
- $SAFE —set to 0 by default. Setting $SAFE
  to 1 will prevent Ruby from running potentially unsafe methods like eval on
  tainted data by raising a SecurityError .

#+begin_src ruby
$? # return global status of last command
$SAFE
#+end_src
** Comparison
   #+begin_src ruby
   # ==
   # ===
   # <=>
   # =~
   # eql?
   # equal?
   # !=
   # !~
   #+end_src
** Conditional
   #+begin_src ruby
   '11' || 11
   '11' or 11 # same precedence
   var ||= "default value" # assign a value to a variable only if that variable isn’t already set


   '11' && 11 # higher precedence
   '11' and 11

   !true
   not true
   #+end_src
** Blocks
*** block-local variables
   #+begin_src ruby
   square = "yes"
   total = 0
   [ 1, 2, 3 ].each do |val; square|
     square = val * val
     total += square
   end
   puts "Total = #{total}, square = #{square}"
   produces:
     Total = 14, square = yes
   #+end_src
*** numbered parameters
#+begin_src ruby
[1,2,3].each { puts _1 }
#+end_src
*** yield
   #+begin_src ruby

   def foo
     yield
   end

   def bar
     if block_given?
       yield
     else
       'lol'
     end

     foo { p 'meh' }
     bar # => lol
     bar { p 'yahoo' } # => yahoo
   #+end_src
*** yield_self
refers to the object we’re calling the method on.

#+begin_src ruby
n_squared = ->(n) { n ** 2 }

2.yield_self(&n_squared) # 4
  .yield_self(&n_squared) # 16

#+end_src
** Regular Expressions
- Regexp
#+begin_src ruby
# object form
Regexp.new

# literal form
/pattern/
%r{pattern}

#+end_src

** Operators
   #+begin_src ruby
   val.to_s =~ /3/
   #+end_src
** System calls
*** open3
opens communication with an external program and gives you handles on the
external program’s standard input, standard output, and standard error streams.

#+begin_src ruby
require 'open3'

#+end_src

*** open
- | pipe The pipe in front of the word cat indicates that we’re looking to talk to a program and not open a file.
#+begin_src ruby

d = open("|cat", "w+")
d.puts "Hello world"
d.gets
d.close


open("|cat", "w+") {|p| p.puts("hi"); p.gets }
#+end_src
** Date/Time
   #+begin_src ruby
   require 'date'
   d = date.today

   require 'time'
   t = time.zxcz
   #+end_src
** Lazy
   #+begin_src ruby
   (1..Float::INFINITY).lazy.select {|n| n % 3 == 0 }
   #+end_src
** Eval
*** eval
#+begin_src ruby
eval("puts 'x'")
eval("puts 'x'", b) # b for binding
#+end_src
*** instance_eval
    - class methods
*** Binding
#+begin_src ruby
def use_a_binding(b)
  eval("puts str", b)
end
str = "I'm a string in top-level binding!"
use_a_binding(binding)
#+end_src
*** instance_exec
- take arguments. Any arguments you pass it will be passed, in turn, to the code block.
#+begin_src ruby
string = "A sample string"
string.instance_exec("s") {|delim| self.split(delim) }
#+end_src
*** class_eval
- instance methods
#+begin_src ruby
c = Class.new
c.class_eval do
  def some_method
    puts "Created in class_eval"
  end
end

c_instance = c.new
c_instance.some_method
#+end_src
*** evals perils
#+begin_src ruby
x = gets
"any user input here\n"
x.tainted?
true
#+end_src
*** define_method
#+begin_src ruby
C.class_eval { define_method ("talk") { puts var }
#+end_src
** Callbacks / Hooks
Callbacks and hooks methods are called when a particular event takes place during the run of a program.

#+begin_src ruby
#+end_src
*** method_missing
*** respond_to_missingp

** Metaprogramming
- objects and classes are first-class citizens

*** instance_variable_set
*** instance_varibles
*** class
**** instance_methods
*** Object#instance_exec
*** Module#class_exec
*** Module#module_exec
** Misc
*** table

|                        |                                                                                                           |                                                                                                             |
|------------------------+-----------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------|
| drop_while             | a.drop_while { true }                                                                                     |                                                                                                             |
| take_while             | a.take_while { true }                                                                                     |                                                                                                             |
| find_all               | a.find_all ¦ a.select                                                                                     |                                                                                                             |
| reject                 | a.reject { ¦i¦ i > 4 } ¦ a.reject! { ¦i¦ i > 4 }                                                          |                                                                                                             |
| select                 |                                                                                                           |                                                                                                             |
| grep                   | a.grep(//o//) ¦ a.grep(String) ¦ a.grep(50..100) ¦                                                          |                                                                                                             |
| group_by               | a.group_by { ¦s¦ s.size }                                                                                 |                                                                                                             |
| match                  | //n//.match(s)                                                                                              |                                                                                                             |
| String                 | 'C'.size ¦ each_byte ¦ each_line ¦ each_codepoint ¦ each_char ¦ s.bytes ¦                                 |                                                                                                             |
| min/min_by             | a.min { ¦a,b¦ a.size <=> b.size } ¦  a.min { ¦lang¦ lang.size } ¦ state_hash.min_by { ¦name, abbr¦ name } |                                                                                                             |
| max/max_by             |                                                                                                           |                                                                                                             |
| minmax/minmax_by       | a.minmax ¦ a.minmax_by { ¦lang¦ lang.size }                                                               |                                                                                                             |
| reverse_each           | [1,2,3].reverse_each { ¦e¦ puts e * 10 }                                                                  |                                                                                                             |
| with_index             | letters.each.with_index {¦(key,value),i¦ puts i }                                                         |                                                                                                             |
| each_index             | names.each.with_index(1) { ¦pres, i¦ p i }                                                                |                                                                                                             |
| each_slice             |                                                                                                           |                                                                                                             |
| each_cons              |                                                                                                           |                                                                                                             |
| slice_before           | a.slice_before(\/=/).to_a ¦ (1..10).slice_before { ¦num¦ num % 2 == 0 }.to_a ¦                            |                                                                                                             |
| slice_after            |                                                                                                           |                                                                                                             |
| slice_when             | a.slice_when { ¦i,j¦ i == j }.to_a                                                                        |                                                                                                             |
| inject/reduce          | [1,2,3,4].inject(:+)                                                                                      |                                                                                                             |
| cycle                  |                                                                                                           |                                                                                                             |
| map                    | names.map { ¦name¦ name.upcase } ¦  x = 5.times.map { Apple.new(rand(100..900)) }                         |                                                                                                             |
| map!                   |                                                                                                           |                                                                                                             |
| symbol-argument blocks | names.map(&:upcase)                                                                                       |                                                                                                             |
| <=>                    | Apple#<=> ¦ Apple.sort { ¦a,b¦ a.brand <=> b.brand } ¦                                                    | implementing a spaceship test method is enough to sort a class, or use a block to sort, or even override it |
| comparable             | Apple#<=> ¦                                                                                               | include comparable                                                                                          |
| clamp                  |                                                                                                           |                                                                                                             |
| between                |                                                                                                           |                                                                                                             |
| functions              | -> (args) {} ¦ Sum = -> (a, b) { a + b }                                                                  |                                                                                                             |
| <<                     | yielder                                                                                                   |                                                                                                             |
|                        | enum_for                                                                                                  |                                                                                                             |
|                        | to_enum                                                                                                   |                                                                                                             |
| dup                    |                                                                                                           |                                                                                                             |
|------------------------+-----------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------|

*** dig
*** fetch
*** pluck
*** succ
   increments a string value
   #+begin_src ruby
   'e'.succ # f
   #+end_src
*** append <<

*** defined?
*** writable object attribute
   #+begin_src ruby
   class ProjectList
     def initialize
       @projects = []
     end
     def projects=(list)
       @projects = list.map(&:upcase)
     end
     def [](offset)
       @projects[offset]
     end
   end

   # store list of names in uppercase
   list = ProjectList.new
   list.projects = %w{ strip sand prime sand paint sand paint rub paint }
   list[3]   # => "SAND"
   list[4]   # => "PAINT"
   #+end_src

   - attribute-setting methods
*** path
   #+begin_src ruby
   $LOAD_PATH.each { |x| puts x } or $:

   # add dir to path
   $:.push '/your/directory/here'
   require 'yourfile'
   #+end_src
** Concepts
*** Iterator
    - is a method
    - it start and finish in the same call
*** Methods
**** Methods chaining
     creates a new object at it chains
     #+begin_src ruby
     puts animals.select {¦n¦ n[0] < 'M' }.map(&:upcase).join(", ")
     #+end_src
*** Enumerator
    - is an object
    - chaining
    - block based
    - method attachment (enum_for)
    - un-overriding of methods in Enumerable
    - maintain state
    - is an enumerable object
    - can add enumerability to objects
    - can stop and resume collection cycling
** Instructions
*** Rbenv
    rbenv global 2.3.0 && rbenv rehash
*** misc
    - $! → Exception: The exception object passed to raise.
    - $@ → Array: The stack backtrace generated by the last exception.
    - $& → String : The string matched (following a successful pattern match). This variable is local to the current scope.

** Builtin Modifications
*** additive change
- adding a method that doesn’t exist.
- doesn’t clobber existing methods.
-
*** Pass-through
- overriding an existing method in such a way that the original version of the method ends up getting called along with the new version.
-
*** Additive / Pass-Through Hybrids
- is a method that has the same name as an existing core
  method, calls the old version of the method (so it’s not an out-and-out
  replacement), and adds something to the method’s interface.
-

** Comments
   #+begin_src ruby
   # one line comment

   =begin
   multiline
   comments
   =end
   #+end_src

** Delimited input
|         |                            |
|---------+----------------------------|
| %q      | Single-quoted string       |
| %Q , %  | Double-quoted string       |
| %w , %W | Array of strings           |
| %s      | A symbol                   |
| %i , %I | Array of symbols           |
| %r      | Regular expression pattern |
| %x      | Shell command              |

- %I , %Q , and %W will preform interpolation

* Standard Library
** Packagement
*** gem
    |                             |   |
    |-----------------------------+---|
    | install <name> -v <version> |   |
    | which                       |   |
    | list                        |   |
    | search                      |   |
    | env                         |   |
    | info <name>                 |   |

#+begin_src shell-script
   gem build GEM.gemspec
   gem install --user-install pkg/GEM
   gem list GEM -d
#+end_src
** Variables
*** global variables
- $0
- $:
- $PROGRAM_NAME
- ARGV
- ARGF.{gets,filename,file,lineno,inplace_mode}
- RubyVM::DEFAULT_PARAMS

*** environment variables
#+begin_src ruby
ENV['SHELL']
ENV['HOME']
ENV['USER']
ENV.keys.size
ENV.keys[0, 4]
#+end_src

** Objects
*** exit
doesn’t terminate the program immediately — exit first raises a SystemExit exception, which you may catch, and then performs a number
of cleanup actions, including running any registered at_exit methods and object finalizers.

** Numbers
*** Fixnum
*** Bignum
** Testing
*** Minitest
**** setup

** Console
*** irb
**** cli
|                                            |                               |
|--------------------------------------------+-------------------------------|
| -r ./<file>                                |                               |
| irb_load                                   |                               |
| irb_source                                 |                               |
| --prompt <my-prompt>                       |                               |
| -I                                         | include path                  |
| RUBYOPT=--enable-frozen-string-literal irb | freeze all strings in section |
|                                            |                               |
**** inside
     |                           |         |
     |---------------------------+---------|
     | context.use_tracer = true | tracker |
     |                           |         |
** Serialization
*** JSON
**** Commands
     |                 |   |
     |-----------------+---|
     | generate <this> |   |

*** YAML
**** Commands
     |                 |               |
     |-----------------+---------------|
     | YAML.dump <obj> |               |
     | <obj>.to_yaml   | same as above |
     |                 |               |

** Documentation
*** Rdoc
    - nodoc: [all]

*** console
    |        |   |
    |--------+---|
    | --all  |   |
    | --fmt  |   |
    | --main |   |

** System
*** FFI
- Foreign Function Interface
- gives you access to external libraries

#+begin_src ruby
require 'ffi'

module A
  extend FFI::Library
  ffi_lib 'c'
end
#+end_src
* Modules
** continuation
   - require 'continuation'
** Require
*** require_relative
Prior Ruby 2.0

#+begin_src ruby
$: << File.dirname(__FILE__)
require 'other_file'
#+end_src

nowadays
#+begin_src ruby
require_relative 'other_file'
#+end_src
** Tempfile
- `new` creates a Tempfile object (as you would expect),
- `create` gives you a File object.

#+begin_src ruby
require 'tempfile'

Tempfile.create { |f| f << "abc\n" }
#+end_src
** IO
*** methods
**** sysopen
#+begin_src ruby
fd = IO.sysopen('/dev/null', 'w')

# 10
#+end_src
**** eof?
**** open
**** each
**** close
**** each_byte
** Pathname
*** new
#+begin_src ruby
Pathname.new('/usr/local/lib/ruby/1.8')
#+end_src
*** each_filename
*** each_entry
** ObjectSpade
*** each_object
#+begin_src ruby
ObjectSpace.each_object(Numeric) {|n| puts("The number is #{n}")}

def subclasses_of(superclass)
  subclasses = []
  ObjectSpace.each_object(Class) do |k|
    next if !k.ancestors.include?(superclass) || superclass == k ||
            k.to_s.include?('::') || subclasses.include?(k.to_s)
    subclasses << k.to_s
  end
  subclasses
end

subclasses_of Numeric # ["Complex", "Rational", "Float", "Integer"]
#+end_src

** forwardable
The Forwardable module provides delegation of specified methods to a designated
object, using the methods def_delegator and def_delegators.

*** def_delegators
** Errno

** Kernel
*** variables
**** local_variables
**** global_variables
|            |                                                                          |
|------------+--------------------------------------------------------------------------|
| $:         | library load path, also available as                                     |
| $LOAD_PATH | idem                                                                     |
| $0         | name of the file in which execution of the current program was initiated |
| $FILENAME  | (the name of the file currently being executed                           |
| _          | value of the last expression evaluated by irb.                           |
|            |                                                                          |
**** itself
#+begin_src ruby

"Ruby".itself # "Ruby"
[1, 1, 3, 4, 5, 5, 5, 6, 7].itself # [1, 1, 3, 4, 5, 5, 5, 6, 7]

%w(joe, joe, david, matz, david, matz, joe).group_by { |name | name }
%w(joe, joe, david, matz, david, matz, joe).group_by(&:itself) # same as above

#+end_src

**** yield_self / then
- named to `then` in 3.0

#+begin_src ruby

"Ruby".yield_self { |str| str + " meh" }

add_newline = -> (str) { str + "\n" }
welcome = -> (str) { "Welcome, " + str.upcase + "!" }
"joe".yield_self(&welcome).yield_self(&add_newline) + "We’re glad you’re here!" # "Welcome, JOE!\nWe’re glad you’re here!"

# then
(1..10).then { |r| r.member?(rand(15)) } # returns true or false
(rand(10) + 1).then { |x| x.odd? ? x + 1 : x } # returns an even number between 2 and 10.

#+end_src
** ObjectSpace
The objspace library extends the ObjectSpace module and adds several
methods to get internal statistic information about object/memory
management.
** Enumerable
*** examples
#+begin_src ruby
class Account
  attr_accessor :name, :balance

  def initialize(name, balance)
    @name = name
    @balance = balance
  end

  def <=>(other)
    balance <=> other.balance
  end
end

class Portfolio
  include Enumerable

  def initialize
    @accounts = []
  end

  def each(&block)
    @accounts.each(&block)
  end

  def add_account(account)
    @accounts << account
  end
end

my_portfolio.any? {|account| account.balance > 2000}
my_portfolio.all? {|account| account.balance > = 10}
#+end_src

#+begin_src ruby
# iterate over only those lines that end with a d
File.open("ordinal").grep(/d$/) do |line|
  puts line
end
#+end_src
*** methods
**** compact
    #+begin_src ruby

   enum = [1, nil, 3, nil, 5].to_enum.compact
   enum = [1, nil, 3, nil, 5].to_enum.lazy.compact

    #+end_src
**** group_by
#+begin_src ruby

%w(joe, joe, david, matz, david, matz, joe).group_by { |name | name }
# {"joe,"=>["joe,", "joe,"], "david,"=>["david,", "david,"], "matz,"=>["matz,", "matz,"], "joe"=>["joe"]}

#+end_src
**** cycle
When called with positive Integer argument count and a block, calls the
block with each element, then does so again, until it has done so count
times; returns nil


#+begin_src ruby
[12, 18, 20, 02].cycle(3) { |el| puts el*4 } # 48 72 80 8 48 72 80 8 48 72 80                  8
#+end_src
**** filter_map
combine the select & map

#+begin_src ruby
(1..8).filter_map { |n| n ** 2 if n.even? } # [4, 16, 36, 64]
#+end_src

**** grep
#+begin_src ruby

['gr', 'xr', 'cd', 'dg'].grep /r/ # ["gr", "xr"]
['gr', 'xr', 1, 2].grep Integer # [1, 2]
["apple", "orange", "banana"].grep(/^a/)
["apple", "orange", "banana"].grep(/e$/)
[9, 10, 11, 20].grep(5..10) # [9, 10]
[9, 10, 11, 20].grep(5..10) { |n| n * 2 } # [18, 20]

times_two = ->(x) { x * 2 }
numbers.grep(5..10, &times_two) # [18, 20]

#+end_src
**** tally
counts all the elements in an array & returns a hash with their counts.

#+begin_src ruby
%w(a a a b b c).tally
#+end_src
**** all?
**** sort
** Enumerator
*** lazy
#+begin_src ruby
def Integer.all
  Enumerator.new do |yielder, n: 0|
	  loop { yielder.yield(n += 1) }
  end.lazy
end


def find_multiples(num, mult)
  (1..Float::INFINITY).lazy.select { |x| x % mult == 0}.first(num)
end
find_multiples(3, 50) # [50, 100, 150]


first_3_multiples = self.method(:find_multiples).curry.(3) # #<Proc:0x000055c3b7d76088 (lambda)>
first_5_multiples = self.method(:find_multiples).curry.(5) # #<Proc:0x000055c3b8243368 (lambda)>
first_3_multiples.(256) # [256, 512, 768]


squares = (1..Float::INFINITY).lazy.map { |x| x * x } # #<Enumerator::Lazy: #<Enumerator::Lazy: 1..Infinity>:map>
squares.first 4 # [1, 4, 9, 16]

#+end_src
*** each_car
*** each
*** to_enum/enum_for
    #+begin_src ruby
    a = [ 1, 3, "cat" ]
    h = { dog: "canine", fox: "vulpine" }

    # Create Enumerators
    enum_a = a.to_enum
    enum_h = h.to_enum

    enum_a.next # 1
    enum_h.next # [:dog, "canine"]
    enum_a.next # 3
    enum_h.next # [:fox, "vulpine"]

    enum_a = a.each # create an Enumerator using an internal iterator
    #+end_src
*** enum_for
   #+begin_src ruby
   e = names.enum_for(:inject, "Names: ")
   #+end_src
*** generator
*** produce
Produces an infinite sequence where each next element is calculated by applying
the block to the previous element.

#+begin_src ruby
Enumerator.produce(1, &:next).take(5) # [1, 2, 3, 4, 5]
#+end_src

*** upto
#+begin_src ruby
0.upto(9).each(&method(:puts))
#+end_src
** Iterators
- internal iterator
- external iterator

#+begin_src ruby
3.times { p 'meh' } # easy to avoid fence-post and off-by-one errors

9.downto(5) { p 'meh' }

0.upto(9) { p 'meh' }

0.step(12, 3) {|x| print x, " " }

[ 1, 1, 2, 3, 5 ].each {|val| print val, " " }
#+end_src

*** collect
   #+begin_src ruby
   ["H", "A", "L"].collect {|x| x.succ } # => ["I", "B", "M"]
   #+end_src
*** each
*** select/inject
   accumulate a value across the members of a collection
*** each_cons(<value>)
*** find
   #+begin_src ruby
   a.find { ¦n¦ n > 5 }
   a.find { ¦n¦ n > 5 }
   a.find_all
   a.select
   a.reject
   a.map
   #+end_src

*** each_slice
   #+begin_src ruby
   animals.each_slice(2).map do |predator, prey|
   #+end_src
*** each_with_object
*** with_object
*** with_index.
*** reject

*** each_byte

*** each_char
*** tap
*** with_index
   #+begin_src ruby
   ['a'..'z').map.with_index {|letter,i| [letter, i] } // Output: [["a", 0], ["b", 1], etc.]
   my_enum.take(5).force // actual result rather than lazy enumerator
   #+end_src
*** loops
   #+begin_src ruby
   # WHILE , UNTIL , and FOR loops are built into the language and do not introduce new scope;

   while line = gets
     # ...
   end

   until play_list.duration > 60
     play_list.add(song_list.pop)
   end

   # when an enumerator object runs out of values inside a loop , the loop will terminate cleanly.
   # newly local variables created in LOOP are not accessible outside the block
   loop do
     puts "#{short_enum.next} - #{long_enum.next}"
   end

   # not a ruby way, translated by ruby to x.each
   for song in playlist
     song.play
   end


   # NEXT skips to the end of the loop, effectively starting the next iteration
   # BREAKn

   i=0
   loop do
     i += 1
     next if i < 3
     print i
     break if i > 4 # If a conventional loop doesn’t execute a break , its value is nil .
   end

   # REDO repeats the current iteration of the loop from the start but without reevaluating
   # the condition or fetching the next element (in an iterator)
   while line = gets
     next if line =~ /^\s*#/   # skip comments
     break if line =~ /^END/   # stop at end

     # substitute stuff in backticks and try again
     redo if line.gsub!(/`(.*?)`/) { eval($1) }

     # process line ...
   end



   #+end_src
*** times

* Cli
** ruby

|           |   |
|-----------+---|
| -l        |   |
| -I  <lib> |   |
** gem
|                    |   |
|--------------------+---|
| search             |   |
| list               |   |
| query              |   |
| install            |   |
| environment gemdir |   |
| build              |   |
| server             |   |

** irb

** ri
ri <ClassName>

#+begin_src shell
ri GC
ri assoc
ri Rake

export RI="--format ansi --width 70"
#+end_src

* Toolings
** Online
https://rubular.com
* Videos
  https://www.youtube.com/watch?v=hnGVFzZ0DuI - "300x faster ruby" - Dana Sherson
* Best Practices
** Methods
- methods have four parts
  1. Collecting input
  2. Performing work
  3. Delivering output
  4. Handling failures
 - asd
   1. We must identify the messages we want to send in order to accomplish the task at hand.
   2. We must identify the roles which correspond to those messages.
   3. We must ensure the method's logic receives objects which can play those roles
