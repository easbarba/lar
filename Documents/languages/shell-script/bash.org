#+TITLE: Bash

* Progress
   | book                  | chapter | @ | revision |
   |-----------------------+---------+---+----------|
   | Bash Reference Manual |         |   |          |

* Features
** Redirection
*** File descriptors
https://www.gnu.org/software/bash/manual/html_node/Redirections.html
https://tldp.org/LDP/abs/html/io-redirection.html
** set
    |             |                                                    |
    |-------------+----------------------------------------------------|
    | -o pipefail |                                                    |
    | -e          | exit on error                                      |
    | -x          | Print a trace of simple commands                   |
    | --          | the positional parameters are set to the arguments |
    | -f          | Disable filename expansion (globbing).             |
    | -p          | Turn on privileged mode.                           |
    | -t          | Exit after reading and executing one command.      |
    | +           | options to be turned off.                          |
** variables
*** undeclared vars
Use :- if you want to test variables that could be undeclared. For instance: if
[ "${NAME:-}" = "Kevin" ] will set $NAME to be empty if it's not declared.

** read
** shift
    shift: shift cli args to next right
** <<<
    here-string, give a pre-made string of text to a program
** >&2
** shopt
** options
*** --init-file
     use alternative init file
*** -c
     run command and arguments
** man
    - bash-builtins: describe bash built in features
** >
    echo 'asd' > temp  | create a file or overwrite existent one
** >>
    echo 'asd' >> temp | create a file or append to end of existent one
** << EOF > OEF
    here documents
** <<<
    here-string
** unicode

PS: remove + sign as shell does not what is.

#+begin_src shell

# U+f026

echo -e "\Uf026"

#+end_src
** Group Commands
*** subshell (...)
     Placing a list of commands between parentheses causes a subshell
     environment to be created (see Command Execution Environment), and
     each of the commands in list to be executed in that subshell.
     Since the list is executed in a subshell, variable assignments do
     not remain in effect after the subshell completes.

     The parentheses are operators, and are recognized as separate
     tokens by the shell even if they are not separated from the list
     by whitespace.
     #+begin_src shell-script
     ()
     #+end_src
*** subshell {...}
     Placing a list of commands between curly braces causes the
     list to be executed in the current shell context. No subshell
     is created. The semicolon (or newline) following list is
     required.

     The braces are reserved words, so they must be separated from the
     list by blanks or other shell metacharacters.
     #+begin_src shell-script
     {...}
     #+end_src
* Tips
   #+begin_src shell-script
   #  get word after $char in string $var
   ${var##*char}

   # return s
   ${var%sub}

   # variable inline assignment
   var=$(test && echo "A" || echo "B")

   # variable inline assignment numeric    |
   (( a = b==5 ? c : d )) or let a=b==5?c:d;

   # return arguments of function as array |
   $@
						|                                       |

   #+end_src

* Resources
   - http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html#toc6

   - https://bash.cyberciti.biz/guide/Main_Page

   - https://wiki.bash-hackers.org

   - https://explainshell.com/
** Bash Articles
    https://wiki.bash-hackers.org/syntax/arrays

    https://phoxis.org/2010/03/14/read-multiple-arg-bash-script/

    https://likegeeks.com/linux-command-line-tricks/

    https://linuxize.com/post/bash-while-loop/

    https://www.linuxjournal.com/content/return-values-bash-functions

    https://natelandau.com/bash-scripting-utilities/

** Bash Quick Tutorial
    #+BEGIN_SRC shell-script
    # Check if string contains a sub-string.
    if [[ "$var" == *sub_string* ]]; then
	printf '%s\n' "sub_string is in var."
    fi

    # Inverse (substring not in string).
    if [[ "$var" != *sub_string* ]]; then
	printf '%s\n' "sub_string is not in var."
    fi

    # This works for arrays too!
    if [[ "${arr[*]}" == *sub_string* ]]; then
	printf '%s\n' "sub_string is in array."
    fi

    # Check if string starts with sub-string.
    if [[ "$var" == sub_string* ]]; then
	printf '%s\n' "var starts with sub_string."
    fi

    # Inverse (var doesn't start with sub_string).
    if [[ "$var" != sub_string* ]]; then
	printf '%s\n' "var does not start with sub_string."
    fi

    # Check if string ends with sub-string.
    if [[ "$var" == *sub_string ]]; then
	printf '%s\n' "var ends with sub_string."
    fi

    # Inverse (var doesn't start with sub_string).
    if [[ "$var" != *sub_string ]]; then
	printf '%s\n' "var does not end with sub_string."
    fi

    # Variables
    Assign and access a variable using a variable.

    hello_world="test"

    # Create the variable name.
    var1="world"
    var2="hello_${var1}"

    # Print the value of the variable name stored in 'hello_$var1'.
    printf '%s\n' "${!var2}"

    # Loop over a range of numbers.
    # Loop from 0-100 (no variable support).
    for i in {0..100}; do
	printf '%s\n' "$i"
    done

    # Loop over a variable range of numbers.

    # Don't use seq.

    # Loop from 0-VAR.
    VAR=50
    for ((i=0;i<=VAR;i++)); do
	printf '%s\n' "$i"
    done

    # Loop over an array.

    arr=(apples oranges tomatoes)

    # Just elements.
    for element in "${arr[@]}"; do
	printf '%s\n' "$element"
    done

    # Loop over an array with an index.

    arr=(apples oranges tomatoes)

    # Elements and index.
    for i in "${!arr[@]}"; do
	printf '%s\n' "${arr[$i]}"
    done

    # Alternative method.
    for ((i=0;i<${#arr[@]};i++)); do
	printf '%s\n' "${arr[$i]}"
    done

    # Loop over the contents of a file.

    while read -r line; do
	printf '%s\n' "$line"
    done < "file"

    # Loop over files and directories.

    # Don’t use ls.

    # Greedy example.
    for file in *; do
	printf '%s\n' "$file"
    done

    # PNG files in dir.
    for file in ~/Pictures/*.png; do
	printf '%s\n' "$file"
    done

    # Iterate over directories.
    for dir in ~/Downloads/*/; do
	printf '%s\n' "$dir"
    done

    # Iterate recursively.
    shopt -s globstar
    for file in ~/Pictures/**/*; do
	printf '%s\n' "$file"
    done
    shopt -u globstar

    # File handling
    # Read a file to a string.

    # Alternative to the cat command.

    file_data="$(<"file")"

    # Read a file to an array (by line).

    # Alternative to the cat command.

    # Bash <4
    IFS=$'\n' read -d "" -ra file_data < "file"

    # Bash 4+
    mapfile -t file_data < "file"

    # Split a string on a delimiter. string="1,2,3"
    # To multiple variables.
    IFS=, read -r var1 var2 var3 <<< "$string"

    # To an array.
    IFSA=, read -ra vars <<< "$string"

    # Create an empty file.

    # Alternative to touch.

    # Shortest.
    > file
    :> file

    # Longer alternatives:
    echo -n > file
    printf '' > file

    # Arithmetic
    # Simpler syntax to set variables.

    # Simple math
    ((var=1+2))

    # Decrement/Increment variable
    ((var++))
    ((var--))
    ((var+=1))
    ((var-=1))

    # Using variables
    ((var=var2*arr[2]))

    # Ternary tests.

    # Set the value of var to var2 if var2 is greater than var.
    # var: variable to set.
    # var2>var: Condition to test.
    # ?var2: If the test succeeds.
    # :var: If the test fails.
    ((var=var2>var?var2:var))

    # Shorter for loop syntax.

    # Tiny C Style.
    for((;i++<10;)){ echo "$i";}

       # Undocumented method.
       for i in {1..10};{ echo "$i";}

		# Expansion.
		for i in {1..10}; do echo "$i"; done

		# C Style.
		for((i=0;i<=10;i++)); do echo "$i"; done

		# Shorter infinite loops.

		# Normal method
		while :; do echo hi; done

		# Shorter
		for((;;)){ echo hi;}

		    # Shorter function declaration.

		    # Normal method
		    f(){ echo hi;}

		    # Using a subshell
		    f()(echo hi)

		    # Using arithmetic
		    # You can use this to assign integer values.
		    # Example: f a=1
		    #          f a++
		    f()(($1))

		    # Using tests, loops etc.
		    # NOTE: You can also use ‘while’, ‘until’, ‘case’, ‘(())’, ‘[[]]’.
		    f()if true; then echo "$1"; fi
		    f()for i in "$@"; do echo "$i"; done

		    Shorter if syntax.

		    # One line
		    # Note: The 3rd statement may run when the 1st is true
		    [[ "$var" == hello ]] && echo hi || echo bye
		    [[ "$var" == hello ]] && { echo hi; echo there; } || echo bye

		    # Multi line (no else, single statement)
		    # Note: The exit status may not be the same as with an if statement
		    [[ "$var" == hello ]] && \
			echo hi

		    # Multi line (no else)
		    [[ "$var" == hello ]] && {
			echo hi
			# ...
		    }

		    # Simpler case statement to set variable.

		    # We can use the : builtin to avoid repeating variable= in a case statement. The $_ variable stores the last argument of the last successful command. : always succeeds so we can abuse it to store the variable value.

		    # Example snippet from Neofetch.
		    case "$(uname)" in
			"Linux" | "GNU"*)
			    : "Linux"
			    ;;

			,*"BSD" | "DragonFly" | "Bitrig")
			    : "BSD"
			    ;;

			"CYGWIN"* | "MSYS"* | "MINGW"*)
			    : "Windows"
			    ;;

			,*)
			    printf '%s\n' "Unknown OS detected, aborting..." >&2
			    exit 1
			    ;;
		    esac

		    # Finally, set the variable.
		    os="$_"

		    #     Internal Variables

		    #     NOTE: This list does not include every internal variable (You can help by adding a missing entry!).

		    #     For a complete list, see: http://tldp.org/LDP/abs/html/internalvariables.html
		    # Get the location to the bash binary.

		    "$BASH"

		    # Get the version of the current running bash process.

		    # As a string.
		    "$BASH_VERSION"

		    # As an array.
		    "${BASH_VERSINFO[@]}"

		    # Open the user's preferred text editor.

		    "$EDITOR" "$file"

		    # NOTE: This variable may be empty, set a fallback value.
		    "${EDITOR:-vi}" "$file"

		    Get the name of the current function.

		    # Current function.
		    "${FUNCNAME[0]}"

		    # Parent function.
		    "${FUNCNAME[1]}"

		    # So on and so forth.
		    "${FUNCNAME[2]}"
		    "${FUNCNAME[3]}"

		    # All functions including parents.
		    "${FUNCNAME[@]}"

		    Get the host-name of the system.

		    "$HOSTNAME"

		    # NOTE: This variable may be empty.
		    # Optionally set a fallback to the hostname command.
		    "${HOSTNAME:-$(hostname)}"

		    # Get the architecture of the Operating System.

		    "$HOSTTYPE"

		    # Get the name of the Operating System / Kernel.

		    # This can be used to add conditional support for different Operating Systems without needing to call uname.

		    "$OSTYPE"

		    # Get the current working directory.

		    # This is an alternative to the pwd built-in.

		    "$PWD"

		    # Get the number of seconds the script has been running.

		    # Check if a program is in the user's PATH.

		    # There are 3 ways to do this and you can use either of
		    # these in the same way.
		    type -p executable_name &>/dev/null
		    hash executable_name &>/dev/null
		    command -v executable_name &>/dev/null

		    # As a test.
		    if type -p executable_name &>/dev/null; then
			# Program is in PATH.
		    fi

		    # Inverse.
		    if ! type -p executable_name &>/dev/null; then
			# Program is not in PATH.
		    fi

		    # Example (Exit early if program isn't installed).
		    if ! type -p convert &>/dev/null; then
			printf '%s\n' "error: convert isn't installed, exiting..."
			exit 1
		    fi

		    "$SECONDS"

		    # Bypass shell aliases.

		    # alias
		    ls

		    # command
		    # shellcheck disable=SC1001
		    \ls

		    # Bypass shell functions.

		    # function
		    ls

		    # command
		    command ls
    #+END_SRC
* Brace Expansion
#+begin_src shell

mkdir /usr/local/src/bash/{old,new,dist,bugs}
#+end_src

* Environments Vars
** $DIRSTACK
** $BASH_ENV

* Shell Expansions
** Arithmetic Expansion
Arithmetic expansion allows the evaluation of an arithmetic expression and the substitution of the result.

#+begin_src shell
$(( expression ))


#+end_src

** Process Substitution
Process substitution allows a process’s input or output to be referred to using a filename.

#+begin_src shell
<(list)
>(list)

#+end_src
* Pattern Matching
** glob
|     |                                     |
|-----+-------------------------------------|
| ch* | select all files that begin w/ 'ch' |
|     |                                     |


#+begin_src shell
ls ch.*

#+end_src

** any
|         |                                                               |
|---------+---------------------------------------------------------------|
| Do[cw]* | match any file that begins w/ 'Do' and followed by 'c' or 'w' |
|         |                                                               |


#+begin_src shell

echo Do[cw]* # Documents Downloads
echo ch[1-46-9] # all numbers up to 9 but not 5

#+end_src

** any single char
#+begin_src shell

ls ? # a
ls -l ch?.1 # ch1.1 ch2.1

#+end_src
* set
** set
display all environment variables and Shell functions
* Redirection
- > : add or overwrite
- >>: add or append
- < : get input from file to program

#+begin_src shell

ls >filelist
cat f1 f2 >temp
echo "use guix" >>.bashrc

who >temp
wc -l <temp

#+end_src
