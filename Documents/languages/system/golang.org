#+TITLE: Golang

* Summary
    :PROPERTIES:
    :TOC:      :include all :depth 3 :ignore this
    :END:
    :CONTENTS:
    - [[#progress][Progress]]
      - [[#books][Books]]
      - [[#sloc][SLOC]]
    - [[#packages][Packages]]
      - [[#gem][gem]]
      - [[#bundle][bundle]]
	- [[#outdated][outdated]]
	- [[#gem][gem]]
	- [[#install][install]]
	- [[#update][update]]
      - [[#irb][irb]]
	- [[#cli][cli]]
	- [[#inside][inside]]
      - [[#rspec][rspec]]
      - [[#unit-test][unit test]]
      - [[#pry][pry]]
    - [[#features][Features]]
      - [[#project-structure][project structure]]
      - [[#system-errors][System Errors]]
	- [[#usage][usage]]
      - [[#exceptions][exceptions]]
	- [[#errors][Errors]]
	- [[#usage][usage]]
      - [[#writable-object-attribute][writable object attribute]]
      - [[#multithreading][Multithreading]]
	- [[#usage][usage]]
      - [[#modules][modules]]
      - [[#continuation][continuation]]
      - [[#fibers][Fibers]]
	- [[#errors][errors]]
	- [[#usage][usage]]
      - [[#delimited-input][delimited input]]
      - [[#rake][rake]]
	- [[#usage][usage]]
      - [[#gem][gem]]
      - [[#variables][Variables]]
	- [[#class-variables][class variables]]
	- [[#global-variables][global variables]]
      - [[#self][self]]
      - [[#commentary][commentary]]
      - [[#defined][defined?]]
      - [[#iterators][iterators]]
      - [[#block-local-variables][block-local variables]]
      - [[#loops][loops]]
      - [[#statement-modifiers][statement modifiers]]
      - [[#comparison][comparison]]
      - [[#conditional][conditional]]
      - [[#class][class]]
	- [[#class][class]]
      - [[#append-][append <<]]
      - [[#blocks][blocks]]
      - [[#lambda][lambda]]
	- [[#how][How]]
	- [[#usage][Usage]]
      - [[#methods][methods]]
      - [[#yield][yield]]
      - [[#procs][procs]]
      - [[#operators][operators]]
      - [[#enumerable][enumerable]]
      - [[#enumerator][enumerator]]
	- [[#lazy][lazy]]
	- [[#each_car][each_car]]
	- [[#each][each]]
	- [[#to_enumenum_for][to_enum/enum_for]]
      - [[#inject][inject]]
      - [[#select][select]]
      - [[#succ][succ]]
      - [[#collect][collect]]
      - [[#freeze][freeze]]
      - [[#dup][dup]]
      - [[#dig][dig]]
      - [[#fetch][fetch]]
      - [[#tap][tap]]
      - [[#map][map]]
      - [[#pluck][pluck]]
      - [[#quoting][Quoting]]
      - [[#here-documents][here documents]]
      - [[#proc][proc]]
      - [[#do-end-as-param][do end as param]]
      - [[#array][array]]
      - [[#datetime][date/time]]
      - [[#lambda][lambda]]
      - [[#begin-rescue][begin rescue]]
      - [[#hash][hash]]
      - [[#range][range]]
      - [[#sets][sets]]
      - [[#gsub][gsub]]
      - [[#find][find]]
      - [[#map][map]]
      - [[#each_slice][each_slice]]
      - [[#lazy][lazy]]
      - [[#with_index][with_index]]
      - [[#enum_for][enum_for]]
      - [[#more][more]]
      - [[#concepts][Concepts]]
	- [[#iterator][Iterator]]
	- [[#methods][Methods]]
	- [[#enumerator][Enumerator]]
      - [[#instructions][Instructions]]
	- [[#rbenv][Rbenv]]
	- [[#misc][misc]]
    - [[#toolings][Toolings]]
    - [[#videos][Videos]]
    - [[#tests][Tests]]
      - [[#rspec][RSpec]]
      - [[#unit][Unit]]
    :END:
* Progress
** Books
| name                    | chapter     | @                            |
|-------------------------+-------------+------------------------------|
| Go Programming Language | 5 Functions | 5.8. Deferred Function Calls |
| Learning go             | 9 modules   | Importing Third-Party Code   |

** SLOC
| Source Code | folder                | file      | @                 |
|-------------+-----------------------+-----------+-------------------|
| go          | src/archive/tar       | reader.go |                   |
| podman      | cmd/podman/containers | cp.go     | copyFromContainer |

* Features
** Basic Types
- comparable

*** integers
- zero value = 0

|         |        | syn  |
|---------+--------+------|
| int8    | uint8  | byte |
| int16   | uint16 |      |
| int32   | uint32 | rune |
| int64   | uint64 |      |

**** byte
**** int
On a 32-bit CPU, int is a 32-bit signed integer like an
int32. On most 64-bit CPUs, int is a 64-bit signed integer, just like an int64.
**** uint
**** rune
**** uintptr

*** float
- ieee 7554
- %g, %e, %f

|         |   |
|---------+---|
| float32 |   |
| float64 |   |

*** complext
*** literals
|                |                              |
|----------------+------------------------------|
| binary         | 0b                           |
| octal          | 0o                           |
| hex            | 0x                           |
| floating point | 1.2                          |
| rune           | 'a' '\141'                   |
| string         | "meh"                        |
| raw string     | `Greetings and"Salutations"` |
| bool           | true false                   |

#+begin_src go
1234
1_234
#+end_src

*** strings
- immutable
- zero value = ""
- a sequence of bytes, once created, is immutable.
- only use slice/indexing when string contains characters that take up one byte.
- conversion from int to string yields a string of runes.
- extract substrings and code points from strings using the functions in the strings and unicode/utf8
- exa: \xhh
- ocatal: \ooo
- Raw string literals are a convenient way to write regular expressions,

|              |              |
|--------------+--------------|
| immutable    |              |
| zero value   | empty string |
| concatenate  | +            |
| equality     | \==, !=      |
| empty string | s == ""      |
| raw string   | `meh`        |

#+begin_src go
var s string = "Hello there"
var b byte = s[6]
var s string = "Hello there"

// slicing
var s2 string = s[4:7]
var s3 string = s[:5]
var s4 string = s[6:]

fmt.Println("goodbye" + s[5:]) // "goodbye, world"

s[0] = 'L' // compile error: cannot assign to s[0]
#+end_src

// raw strings
const GoUsage = `Go is a tool for managing Go source code.

Usage:
    go command [arguments]
...`



**** functions
- len

*** boolean
- zero value = false
- true or false
- no other type can be converted to a bool, implicitly or explicitly
- convert to boolean with: \== , != , > , < , <= , or >=

*** runes
- single quotes
- chars
- int32 type
- %c, %q

#+begin_src go
ascii := 'a'
unicode := 'D'
newline := '\n'
fmt.Printf("%d %[1]c %[1]q\n", ascii)
// "97 a 'a'"
fmt.Printf("%d %[1]c %[1]q\n", unicode) // "22269 D 'D'"
#+end_src

*** nil
- has no type
- may be assigned to any variable of interface or reference type.
** Agreggate Types
*** Arrays
- == and != to compare arrays
- all elements have same type
- fixed size
- one-dimensional arrays only
- ellipsis ‘‘...’’ means array length is determined by the number of initializers.

#+begin_src go
var x [3]int // 0,0,0
var x = [3]int{10, 20, 30}
var x = [12]int{1, 5: 4, 6, 10: 100, 15} // sparse array
var x = [...]int{10, 20, 30}
var x [2][3]int // simulate multidemensional array
#+end_src
**** functions
***** len
*** Slices
- don’t specify its size
- not comparable
- compare a slice with /nil/:
- slice as arg: any modification to the contents of the slice is reflected in the original variable, but using
  append to change the length isn’t reflected in the original variable, even if
  the slice has a capacity greater than its length.
- test whether a slice is empty w/ len(s) == 0

#+begin_src go
var x = []int{10, 20, 30}
var x = []int{1, 5: 4, 6, 10: 100, 15}
var x [][]int
x[0] = 10
var x []int // nil
var x = []int{} //  zero-length slice, which is non-nil (
x := make([]int, 5)
num := copy(y, x) // indenpedent copy of original slice
#+end_src
**** functions
- len
- append
- make
- copy
**** slicing
- can slice arrays

#+begin_src go
var x = []int{1, 4, 6, 10, 15}
y := x[2:] // 4, 6, 10, 15
n := x[:2] // 1, 4
h := x[0:2:2] // 1,4 with 2 of cap
#+end_src
*** Maps
|            |     |
|------------+-----|
| zero value | nil |

- always return a value, or a zero value
- write to a nil map variable causes a panic.
- can read and write to a map assigned an empty map literal.
- automatically grow as you add key-value pairs
- can use `make` to create a map with a specific initial size.
- not comparable w/ *==*  and *!=*
- comma ok, verifies availability of key
- no way to constrain a map to only allow certain keys
- values in a map must be of the same type
- avoid using maps for input parameters or return values, especially on public APIs

#+begin_src go
var nilMap map[string]int // map[] // 0 length
totalWins := map[string]int{}

teams := map[string][]string {
    "Orcas": []string{"Fred", "Ralph", "Bijou"},
    "Lions": []string{"Sarah", "Peter", "Billie"},
    "Kittens": []string{"Waldo", "Raul", "Ze"},
}

ages := make(map[int][]string, 10)

// comma ok
m := map[string]int{
    "hello": 5,
    "world": 0,
}
v, ok := m["hello"]
fmt.Println(v, ok)

v, ok = m["world"]
fmt.Println(v, ok)

v, ok = m["goodbye"]
if !ok { fmt.Print("MEEEEEEEEEEH") }

delete(m, "hello")

#+end_src
**** functions
- delete
- len
- range

*** Struct
|            |                                                    |
|------------+----------------------------------------------------|
| zero value | composed of the zero values of each of its fields. |
| empty      | struct{}                                           |
| scope      | universe, function                                 |
| values     | different types                                    |
| size       | fixed size                                         |
| repeatable | unique                                             |
| comparable | if all fields are comparable                       |

- named values
- value is called fields
- unkeyed structs
- its value cannot contain itself.
- can assign just some values
- For efficiency, larger struct types are passed/returned from functions indirectly using a pointer


#+begin_src go
type person struct {
	name string
	age  int
	pet  string
}

var fred person

bob := person{}

julia := person{
    "Julia",
    40,
    "cat",
}

	beth := person{
		age:  30,
		name: "beth",
	}

fmt.Println(beth.age)

// annonymous struct

pet := struct {
    name string
    kind string
}{
    name: "Fido",
    kind: "dog",
}

// &Struct notation
pp := &Point{1, 2}
// same as
pp := new(Point)
*pp = Point{1, 2}

#+end_src
** Reference Type
- different named types are not comparable even same underlying type
- conversions are allowed if both has same underlying type T(x)
- if the name is exported (upper-case letter), it’s accessible from other packages as well.
- can declare a user-defined type based on another user-defined type
- type declarations aren’t inheritance
- Needs conversion between sub-typed types
- Cant instance different types to each other, even if sub-typed
- user-defined types based on built-in types, can be used with the operators for those types, but associates different methods.

#+begin_src go
type Celsius float64
type Fahrenheit float64

const (
	AbsoluteZeroC Celsius = -273.15
	FreezingC
	Celsius = 0
	BoilingC
	Celsius = 100
)

func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }
func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }

Celsius == Fahrenheit // false

#+end_src

#+begin_src go
type HighScore Score
type Employee Person

// assigning untyped constants is valid
var i int = 300
var s Score = 100
var hs HighScore = 200
hs = s                  // compilation error!
s = i                   // compilation error!

#+end_src

- can be aliased

#+begin_src go
type Bar = Foo
#+end_src

*** methods
- can be assigned to vars
- methods expression

#+begin_src go
f1 := myAdder.AddTo
fmt.Println(f1(10))           // prints 20

// methods expression

f2 := Adder.AddTo
fmt.Println(f2(myAdder, 15))  // prints 25

#+end_src

*** emb
#+begin_src go
type Employee struct {
    Name         string
    ID           string
}

func (e Employee) Description() string {
    return fmt.Sprintf("%s (%s)", e.Name, e.ID)
}

type Manager struct {
    Employee
    Reports []Employee
}

func (m Manager) FindNewEmployees() []Employee {
    // do business logic
}

m := Manager{
    Employee: Employee{
        Name:         "Bob Bobson",
        ID:             "12345",
    },
    Reports: []Employee{},
}
fmt.Println(m.ID)            // prints 12345
fmt.Println(m.Description()) // prints Bob Bobson (12345)
#+end_src

#+begin_src go
type Inner struct {
    X int
}

type Outer struct {
    Inner
    X int
}
#+end_src
** Interface Types
- zero value = nil
- lists the methods that must be implemented by a concrete type to meet the interface
- method set of the interface.
- can be declared in any block.
- Interfaces are named as “er” in the end.
- depends on behavior allows swap implementations
- accept interfaces, return structs.
- not returning interfaces avoid wversioning.

#+begin_src go
type Stringer interface {
    String() string
}
#+end_src

** Operators
|          |                            |
|----------+----------------------------|
| combined | += , -= , *= ,/= , and %=  |
|          |                            |
| *        |                            |
| /        |                            |
| %        |                            |
| <<       | right shift / power of two |
| >>       | left shift                 |
| &        |                            |
| &^       |                            |
| +        | unary                      |
| -        | unary                      |
| ^        |                            |
| ==       |                            |
| !=       |                            |
| <        |                            |
| <=       |                            |
| >        |                            |
| >=       |                            |
| &&       |                            |
|          |                            |

** import
allows you to access exported constants, variables, functions, and types in
another package.

** Functions
- reference type
- function values are not comparable.
- can return multiple values
- features variadic input params and slice
- By convention, the error is always the last or only result of function.
- must assign all returned values to a single variable or else its compile-error
- named return values are available within the function, initialized to zero-values
- blank returns, returns named return variables (AVOID THIS)
- anonymous functions
- variadic functions, usually suffixed w/ f
- return functions

#+begin_src go
// assign f to nil function
var f func(int) int

// assign var to a function
func square(n int) int { return n * n }
f =  square
fmt.Println(f(3)) // "9"

// can compare function to nil but not another function
if f != nil { ... }

// recursion in go is fast

// lambda/anonymous function
strings.Map(func(r rune) rune { return r + 1 }, "HAL-9000")


// function that returns a lambda
func squares() func() int {
    var x int
    return func() int {
        x++
        return x * x
    }
}
func main() {
    f := squares()
    fmt.Println(f()) // "1"
    fmt.Println(f()) // "4"
    fmt.Println(f())
    fmt.Println(f())
}

// Defer
var mu sync.Mutex
var m = make(map[string]int)

func lookup(key string) int {
    mu.Lock()
    defer mu.Unlock()
    return m[key]
}

func divAndRemainder(numerator, denominator int) (result int, remainder int,
	err error) {
	// assign some values
	result, remainder = 20, 30
	if denominator == 0 {
		return 0, 0, errors.New("cannot divide by zero")
	}
	return numerator / denominator, numerator % denominator, nil
}

func divAndRemainder(numerator, denominator int) (result int, remainder int,
                                                              err error) {
    if denominator == 0 {
        err = errors.New("cannot divide by zero")
        return
    }
    result, remainder = numerator/denominator, numerator%denominator
    return
}

// FUNCTION TYPE DECLARATIONS
type opFuncType func(int,int) int

var opMap = map[string]opFuncType {
	/// code
}

// ANONYMOUS FUNC
func main() {
    for i := 0; i < 5; i++ {
        func(j int) {
            fmt.Println("printing", j, "from inside of an anonymous function")
        }(i)
    }
}

// FUNCS AS PARAMS
sort.Slice(people, func(i int, j int) bool {
    return people[i].Age < people[j].Age
})
fmt.Println(people)

// RETURN FUNCS
func makeMult(base int) func(int) int {
	    return func(factor int) int {
        return base * factor
    }
}
// using
func main() {
    twoBase := makeMult(2)
    threeBase := makeMult(3)
    for i := 0; i < 3; i++ {
        fmt.Println(twoBase(i), threeBase(i))
    }
}


#+end_src
** Defer
- can defer multiple closures in a Go function
- runs after the return
- can supply a function that returns values to a defer, but there’s no way to read those values.
- must suply parentheses when specifying a closure for defer.

#+begin_src go
func main() {
	if len(os.Args) < 2 {
		log.Fatal("no file specified")
	}
	f, err := os.Open(os.Args[1])
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()
	data := make([]byte, 2048)
	for {
		count, err := f.Read(data)
		os.Stdout.Write(data[:count])
		if err != nil {
			if err != io.EOF {
				log.Fatal(err)
			}
			break
		}
	}
}
#+end_src
** Variables
*** package-level variables
- The name of each package-level entity is visible not only throughout the
  source file that contains its declaration, but throughout all the files of the
  package.

*** var
- any block
- assignment
- local declarations are visible only within the function

#+begin_src go
var x int // defaults to 0
var x int = 10
var x, y int = 10, 20 // multiple assignment
var x, y = 10, "hello" // differents types
var x = 10
var (
    x    int
    y        = 20
    z    int = 30
    d, e     = 40, "hello"
    f, g string
)

#+end_src
*** :=
- declaration
- allows assign values to existing variables, as long as there is one new variable on the lefthand side of the :=
- uses type inference
- only function/methods block

#+begin_src go
func main() {
    x := 10
    x, y := 30, "hello"
}
#+end_src
*** tuple assignment
- each variable on the left-hand side is assigned the corresponding value from the right-hand side

#+begin_src go
i, j = j, i // swap values of i and j

x, y = y, x
a[i], a[j] = a[j], a[i]

func gcd(x, y int) int {
	for y != 0 {
		x, y = y, x%y
	}
	return x
}


func fib(n int) int {
	x, y := 0, 1
	for i := 0; i < n; i++ {
		x, y = y, x+y
	}
	return x
}

#+end_src
*** new() function
- new(T) creates an unnamed variable of type T, initializes it to the zero value of T,
  and returns its address, which is a value of typ e *T.
- can be use in a expression instead of dummy variable

#+begin_src go
p := new(int)  // p, of type *int, points to an unnamed int variable
fmt.Println(*p) // "0"
*p = 2 // sets the unnamed int to 2
fmt.Println(*p) // "2"


#+end_src
*** assignment
#+begin_src go
x = 1
d *= 2
x++
x--
#+end_src
*** Const
- a way to give names to literals.
- there is no way in Go to declare that a variable is
- Numeric literals
- true and false
- Strings
- Runes
- The built-in functions complex, real, imag, len, and cap
- Expressions that consist of operators and the preceding values
- typed and untyped constants
- evaluated at compile time
- omiting value but the first and all will have same value
- compiler allows you to create unread constants
- allow untyped constants

#+begin_src go
const x int64 = 10

const (
    idKey   = "id"
    nameKey = "name"
)

const z = 20 * 10

func main() {
    const y = "hello"

    fmt.Println(x)
    fmt.Println(y)

    x = x + 1
    y = "bye"

    fmt.Println(x)
    fmt.Println(y)
}

const (
	a = 1
	b
	c = 2
	d
)
fmt.Println(a, b, c, d) // "1 1 2 2"

#+end_src
*** blank identifier
The blank identifier is the single underscore (_) operator. It is used to ignore
the values returned by functions or import for side-effects.

- Ignore values
- Side effects of import
- Ignore Compiler Errors

#+begin_src go
_, err = os.Read(x)
#+end_src
** Errors
*** errors
*** fmt.Errorf
#+begin_src go
return 0, fmt.Errorf("%d isn't an even number", i)
#+end_src
*** sentinel error
** Blocks
*** Package Levels
*** Universe block
** Control-flow
*** if
#+begin_src go
n := rand.Intn(10)

if n == 0 {
    fmt.Println("That's too low")
} else if n > 5 {
    fmt.Println("That's too big:", n)
} else {
    fmt.Println("That's a good number:", n)
}

if n := rand.Intn(10); n == 0 {
    fmt.Println("That's too low")
} else if n > 5 {
    fmt.Println("That's too big:", n)
} else {
    fmt.Println("That's a good number:", n)
}

#+end_src
*** for
- for-range's value is a copy
- complete for loop doesn’t properly handle multibyte characters, for-range do.

#+begin_src go
// complete for
for i := 0; i < 10; i++ {
    fmt.Println(i)

for i := 1; i <= 100; i++ {
    if i%3 == 0 && i%5 == 0 {
        fmt.Println("FizzBuzz")
        continue
    }
    if i%3 == 0 {
        fmt.Println("Fizz")
        continue
    }
    if i%5 == 0 {
        fmt.Println("Buzz")
        continue
    }
        fmt.Println(i)
}

// condition-only
i := 1
for i < 100 {
        fmt.Println(i)
        i = i * 2
}

// The Infinite for Statement
func main() {
	for {
		// things to do in the loop
		if !CONDITION {
			break
		}
	}
}

// for range

#+end_src
*** switch
- compare relatable values
- Favor blank switch statements over if/else chains when you have multiple related cases
- variable declaration at its head
- no fall through by default
- `fallthrough` keyword for one case continue on to the next one
- no parens after the switch word needed
- default branch spawn if no case matches.
- blank switchs:  do not specify the value to compare against, and it allows to use any boolean comparison

#+begin_src go
words := []string{"a", "cow", "smile", "gopher",
    "octopus", "anthropologist"}
for _, word := range words {
    switch size := len(word); size {
    case 1, 2, 3, 4:
        fmt.Println(word, "is a short word!")
    case 5:
        wordLen := len(word)
        fmt.Println(word, "is exactly the right length:", wordLen)
    case 6, 7, 8, 9:
    default:
        fmt.Println(word, "is a long word!")
    }
}

// blank switch

words := []string{"hi", "salutations", "hello"}
for _, word := range words {
    switch wordLen := len(word); {
    case wordLen < 5:
        fmt.Println(word, "is a short word!")
    case wordLen > 10:
        fmt.Println(word, "is a long word!")
    default:
        fmt.Println(word, "is exactly the right length.")
    }
}

#+end_src
*** goto
** Stop-flow
*** continue
- labelled continue

#+begin_src go


// labelled continue
func main() {
    samples := []string{"hello", "apple_π!"}
outer:
    for _, sample := range samples {
        for i, r := range sample {
            fmt.Println(i, r, string(r))
            if r == 'l' {
                continue outer
            }
        }
        fmt.Println()
    }
}
#+end_src
*** break

** print
#+begin_src go
Printf("%#v\n", w) // # display values in a form similar to Go synVtax.
#+end_src
** Pointers
- zero value: nil
- type uintptr, holds all bits of a pointer value
- The & is the address operator: returns the address of the memory location where the value is stored.
- The * is the indirection operator: pointer type and returns the pointed-to value. dereferencing.
- new() creates a pointer variable. It returns a pointer to a zero value instance of the provided
- return a pointer set to nil from a function, use the comma ok idiom maps and return a value type and a boolean.

#+begin_src go
def main() {
	x := "hello"
	pointToX := &x
}


#+end_src
** mutex
#+begin_src go emacs-lisp
sync.Mutex
#+end_src
** Packages
*** doc comment
Extensive doc comments are often place d in a file of their own, convent ion ally cal le d doc.go

#+begin_src go
// Package tempconv performs Celsius and Fahrenheit conversions.
package meh
#+end_src
* Cli
** vet
      Examines Go source code and reports suspicious constructs

      |   |   |
      |---+---|
      |   |   |

** build
- build project and create binary
|                  |              |
|------------------+--------------|
| -o <name> <file> | set location |
|                  |              |

** get
      |   |   |
      |---+---|
      |   |   |

** doc
** mod
go mod init MODULE_PATH

** install
|               |                            |
|---------------+----------------------------|
| <name>        |                            |
| <name>@latest | latest version of the tool |

#+begin_src shell

go install github.com/rakyll/hey@latest

#+end_src

** run
Run compiles and runs the named main Go package.

** env
- list golang environment variables
*** $GOPATH
*** $GOPROXY
* Structure
** internal
** import
*** blank import
- obsolete

#+begin_src go
import _ "github.com/lib/pq"
#+end_src

** pkg
** cmd
** init function
The init function is a function that takes no argument and returns nothing. This
function executes after the package is imported and maintains the order of
execution. That means multiple init functions can be defined in a file and they
will be called one after another maintaining the order.

- multiple init
- no parameters and returns no values
- runs the first time the package is referenced by another package
- initialize package-level variables that can’t be configured in a single assignment.
- should be immutable
- should declare only init function
- if loads files or accesses the network, document it.
* Config
** go.mod
*** require
lists the modules that your module depends on and the minimum version required
for each one.
*** replace
lets you override the location where a dependent module is located
*** exclude
prevents a specific version of a module from being used.
*** version
minimal version

#+begin_src conf
go 1.15
#+end_src

*** module

#+begin_src conf
module meh.com/gojail/money
#+end_src

** go.sum

* Standard Library
** misc
*** basename
#+begin_src go
fmt.Println(basename("a/b/c.go")) // "c"
fmt.Println(basename("c.d.go"))  // "c.d"
fmt.Println(basename("abc")) // "abc"
#+end_src
*** make
#+begin_src go
make([]T, len)
make([]T, len, cap) // same as make([]T, cap)[:len]
#+end_src

*** iota
- repeats the type and the assignment to all of the subsequent constants in the block

#+begin_src go
type MailCategory int

const (
    Uncategorized MailCategory = iota
    Personal
    Spam
    Social
    Advertisements
)
#+end_src
*** append
** string
- IsUpper
- IsLower
- Contains
- Count
- Fields
- HasPrefix
- Index
- Join

#+begin_src go
strings.Map
#+end_src

** bytes
- bytes.Buffer
- Contains
- Count
- Fields
- HasPrefix
- Index
- Join
** strconv
- Itoa
- ParseInt
- ParseUint
- FormatInt
- FormatUint
** fmt
- Sprintf
- Scanf
- Printf: %T, %t, %x, %c
** unicode
- isDigit
- IsLetter
- IsUpper
- IsLower
** math
|                 |   |
|-----------------+---|
| math.MaxFloat32 |   |
| math.MaxFloat64 |   |
| math.NaN        |   |
| math.IsNaN      |   |
** path
** filepath
** io
#+begin_src go
// end of line
io.EOF

#+end_src

* Terms
- runes: single characthers
* Packages
** tool
*** vet
vet is a tool for static analysis of Go programs.
** golangci-lint
** golint
     |       |                                  |
     |-------+----------------------------------|
     | ./... | runs golint over entire project. |
     |       |                                  |

** goimports
|              |                                                     |
|--------------+-----------------------------------------------------|
| -l <project> | list files whose formatting differs from goimport's |
| -w <project> | write result to (source) file instead of stdout     |
|              |                                                     |

#+begin_src shell-script
goimports -l -w .
#+end_src
