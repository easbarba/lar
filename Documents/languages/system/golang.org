#+TITLE: Golang

* Summary
    :PROPERTIES:
    :TOC:      :include all :depth 3 :ignore this
    :END:
    :CONTENTS:
    - [[#progress][Progress]]
      - [[#books][Books]]
      - [[#sloc][SLOC]]
    - [[#packages][Packages]]
      - [[#gem][gem]]
      - [[#bundle][bundle]]
	- [[#outdated][outdated]]
	- [[#gem][gem]]
	- [[#install][install]]
	- [[#update][update]]
      - [[#irb][irb]]
	- [[#cli][cli]]
	- [[#inside][inside]]
      - [[#rspec][rspec]]
      - [[#unit-test][unit test]]
      - [[#pry][pry]]
    - [[#features][Features]]
      - [[#project-structure][project structure]]
      - [[#system-errors][System Errors]]
	- [[#usage][usage]]
      - [[#exceptions][exceptions]]
	- [[#errors][Errors]]
	- [[#usage][usage]]
      - [[#writable-object-attribute][writable object attribute]]
      - [[#multithreading][Multithreading]]
	- [[#usage][usage]]
      - [[#modules][modules]]
      - [[#continuation][continuation]]
      - [[#fibers][Fibers]]
	- [[#errors][errors]]
	- [[#usage][usage]]
      - [[#delimited-input][delimited input]]
      - [[#rake][rake]]
	- [[#usage][usage]]
      - [[#gem][gem]]
      - [[#variables][Variables]]
	- [[#class-variables][class variables]]
	- [[#global-variables][global variables]]
      - [[#self][self]]
      - [[#commentary][commentary]]
      - [[#defined][defined?]]
      - [[#iterators][iterators]]
      - [[#block-local-variables][block-local variables]]
      - [[#loops][loops]]
      - [[#statement-modifiers][statement modifiers]]
      - [[#comparison][comparison]]
      - [[#conditional][conditional]]
      - [[#class][class]]
	- [[#class][class]]
      - [[#append-][append <<]]
      - [[#blocks][blocks]]
      - [[#lambda][lambda]]
	- [[#how][How]]
	- [[#usage][Usage]]
      - [[#methods][methods]]
      - [[#yield][yield]]
      - [[#procs][procs]]
      - [[#operators][operators]]
      - [[#enumerable][enumerable]]
      - [[#enumerator][enumerator]]
	- [[#lazy][lazy]]
	- [[#each_car][each_car]]
	- [[#each][each]]
	- [[#to_enumenum_for][to_enum/enum_for]]
      - [[#inject][inject]]
      - [[#select][select]]
      - [[#succ][succ]]
      - [[#collect][collect]]
      - [[#freeze][freeze]]
      - [[#dup][dup]]
      - [[#dig][dig]]
      - [[#fetch][fetch]]
      - [[#tap][tap]]
      - [[#map][map]]
      - [[#pluck][pluck]]
      - [[#quoting][Quoting]]
      - [[#here-documents][here documents]]
      - [[#proc][proc]]
      - [[#do-end-as-param][do end as param]]
      - [[#array][array]]
      - [[#datetime][date/time]]
      - [[#lambda][lambda]]
      - [[#begin-rescue][begin rescue]]
      - [[#hash][hash]]
      - [[#range][range]]
      - [[#sets][sets]]
      - [[#gsub][gsub]]
      - [[#find][find]]
      - [[#map][map]]
      - [[#each_slice][each_slice]]
      - [[#lazy][lazy]]
      - [[#with_index][with_index]]
      - [[#enum_for][enum_for]]
      - [[#more][more]]
      - [[#concepts][Concepts]]
	- [[#iterator][Iterator]]
	- [[#methods][Methods]]
	- [[#enumerator][Enumerator]]
      - [[#instructions][Instructions]]
	- [[#rbenv][Rbenv]]
	- [[#misc][misc]]
    - [[#toolings][Toolings]]
    - [[#videos][Videos]]
    - [[#tests][Tests]]
      - [[#rspec][RSpec]]
      - [[#unit][Unit]]
    :END:
* Progress
** Books
| name                    | chapter              | @                                    | late | revision |
|-------------------------+----------------------+--------------------------------------+------+----------|
| Learning go             | Chapter 5. Functions | defer
| Go Programming Language | Methods              | 6.2. Methods with a Pointer Receiver |      |          |

** LDC
| Source Code | folder            | file            | @ |
|-------------+-------------------+-----------------+---|
| go          | src/archive/tar   | example_test.go |   |
| podman      | cmd/podman/common | completion.go   |   |
| consul      | acl               | acl.go          |   |

* Features
** Types
*** numeric
|         |                 |
|---------+-----------------|
| byte    | uint8           |
| int     | int64           |
| uint    | unsigned  int64 |
| complex |                 |
| float   |                 |

**** byte
**** int
On a 32-bit CPU, int is a 32-bit signed integer like an
int32. On most 64-bit CPUs, int is a 64-bit signed integer, just like an int64.
**** uint
**** rune
**** uintptr

**** complext
**** float
*** literals
|                |                              |
|----------------+------------------------------|
| binary         | 0b                           |
| octal          | 0o                           |
| hex            | 0x                           |
| floating point | 1.2                          |
| rune           | 'a' '\141'                   |
| string         | "meh"                        |
| raw string     | `Greetings and"Salutations"` |
| bool           | true false                   |

#+begin_src go
1234
1_234
#+end_src

*** strings
- only use slice/indexing when string contains characters that take up one byte.
- conversion from int to string yields a string of runes.
- extract substrings and code points from strings using the functions in the strings and unicode/utf8

|              |              |
|--------------+--------------|
| immutable    |              |
| zero value   | empty string |
| concatenate  | +            |
| equality     | \==, !=      |
| empty string | s == ""      |
|              |              |

#+begin_src go
var s string = "Hello there"
var b byte = s[6]
var s string = "Hello there"

// slicing
var s2 string = s[4:7]
var s3 string = s[:5]
var s4 string = s[6:]


#+end_src
*** boolean
      - no other type can be converted to a bool, implicitly or explicitly
      - convert to boolean with: \== , != , > , < , <= , or >=

*** runes
      - chars
      - int32 type
      -

*** nil
- has no type

** Collections
#+begin_src go
strings.Map
#+end_src
*** Arrays
- == and != to compare arrays
- one-dimensional arrays only

#+begin_src go
var x [3]int // 0,0,0
var x = [3]int{10, 20, 30}
var x = [12]int{1, 5: 4, 6, 10: 100, 15} // sparse array
var x = [...]int{10, 20, 30}
var x [2][3]int // simulate multidemensional array
#+end_src
**** functions
***** len
*** Slices
- don’t specify its size
- not comparable
- compare a slice with /nil/:
#+begin_src go
var x = []int{10, 20, 30}
var x = []int{1, 5: 4, 6, 10: 100, 15}
var x [][]int
x[0] = 10
var x []int // nil
var x = []int{} //  zero-length slice, which is non-nil (
x := make([]int, 5)
num := copy(y, x) // indenpedent copy of original slice
#+end_src
**** functions
- len
- append
- make
- copy
**** slicing
- can slice arrays

#+begin_src go
var x = []int{1, 4, 6, 10, 15}
y := x[2:] // 4, 6, 10, 15
n := x[:2] // 1, 4
h := x[0:2:2] // 1,4 with 2 of cap
#+end_src
*** Maps
- read a nil map always returns the zero value for the map’s value type.
- write to a nil map variable causes a panic.
- can read and write to a map assigned an empty map literal.
- automatically grow as you add key-value pairs
- can use `make` to create a map with a specific initial size.
- not comparable w/ *==*  and *!=*
- comma ok, verifies availibity of key
- no way to constrain a map to only allow certain keys
- values in a map must be of the same type

#+begin_src go
var nilMap map[string]int // map[] // 0 length
totalWins := map[string]int{}

teams := map[string][]string {
    "Orcas": []string{"Fred", "Ralph", "Bijou"},
    "Lions": []string{"Sarah", "Peter", "Billie"},
    "Kittens": []string{"Waldo", "Raul", "Ze"},
}

ages := make(map[int][]string, 10)

// comma ok
m := map[string]int{
    "hello": 5,
    "world": 0,
}
v, ok := m["hello"]
fmt.Println(v, ok)

v, ok = m["world"]
fmt.Println(v, ok)

v, ok = m["goodbye"]


delete(m, "hello")

#+end_src
**** functions
- delete
*** Struct
- inside or outside of a function
#+begin_src go
type person struct {
	name string
	age  int
	pet  string
}

var fred person

bob := person{}

julia := person{
    "Julia",
    40,
    "cat",
}

	beth := person{
		age:  30,
		name: "beth",
	}

fmt.Println(beth.age)

// annonymous struct

pet := struct {
    name string
    kind string
}{
    name: "Fido",
    kind: "dog",
}


#+end_src
** Operators
*** arithmetic
      |          |                           |
      |----------+---------------------------|
      | combined | += , -= , *= ,/= , and %= |
      |          |                           |
** Functions
- reference type
- function values are not comparable.
- can return multiple values
- features variadic input params and slice
- By convention, the error is always the last or only result of function.
- must assign all returned values to a single variable or else its compile-error
- named return values are available within the function, initialized to zero-values
- blank returns, returns named return variables (AVOID THIS)
- anonymous functions
- return functions

#+begin_src go
// assign f to nil function
var f func(int) int

// assign var to a function
func square(n int) int { return n * n }
f =  square
fmt.Println(f(3)) // "9"

// can compare function to nil but not another function
if f != nil { ... }

// recursion in go is fast

// lambda/anonymous function
strings.Map(func(r rune) rune { return r + 1 }, "HAL-9000")


// function that returns a lambda
func squares() func() int {
    var x int
    return func() int {
        x++
        return x * x
    }
}
func main() {
    f := squares()
    fmt.Println(f()) // "1"
    fmt.Println(f()) // "4"
    fmt.Println(f())
    fmt.Println(f())
}

// Defer
var mu sync.Mutex
var m = make(map[string]int)

func lookup(key string) int {
    mu.Lock()
    defer mu.Unlock()
    return m[key]
}

func divAndRemainder(numerator, denominator int) (result int, remainder int,
	err error) {
	// assign some values
	result, remainder = 20, 30
	if denominator == 0 {
		return 0, 0, errors.New("cannot divide by zero")
	}
	return numerator / denominator, numerator % denominator, nil
}

func divAndRemainder(numerator, denominator int) (result int, remainder int,
                                                              err error) {
    if denominator == 0 {
        err = errors.New("cannot divide by zero")
        return
    }
    result, remainder = numerator/denominator, numerator%denominator
    return
}

// FUNCTION TYPE DECLARATIONS
type opFuncType func(int,int) int

var opMap = map[string]opFuncType {
	/// code
}

// ANONYMOUS FUNC
func main() {
    for i := 0; i < 5; i++ {
        func(j int) {
            fmt.Println("printing", j, "from inside of an anonymous function")
        }(i)
    }
}

// FUNCS AS PARAMS
sort.Slice(people, func(i int, j int) bool {
    return people[i].Age < people[j].Age
})
fmt.Println(people)

// RETURN FUNCS
func makeMult(base int) func(int) int {
	    return func(factor int) int {
        return base * factor
    }
}
// using
func main() {
    twoBase := makeMult(2)
    threeBase := makeMult(3)
    for i := 0; i < 3; i++ {
        fmt.Println(twoBase(i), threeBase(i))
    }
}


#+end_src
** Variables
*** var
#+begin_src go
var x int // defaults to 0
var x int = 10
var x, y int = 10, 20 // multiple assignment
var x, y = 10, "hello" // differents types
var x = 10
var (
    x    int
    y        = 20
    z    int = 30
    d, e     = 40, "hello"
    f, g string
)

#+end_src
*** package-level variables
*** :=
- allows assign values to existing variables, as long as there is one new variable on the lefthand side of the :=
- uses type inference
- within function

#+begin_src go
func main() {
    x := 10
    x, y := 30, "hello"
}
#+end_src
** Blocks
*** Package Levels
*** Universe block
** Control
*** if
#+begin_src go
n := rand.Intn(10)

if n == 0 {
    fmt.Println("That's too low")
} else if n > 5 {
    fmt.Println("That's too big:", n)
} else {
    fmt.Println("That's a good number:", n)
}

if n := rand.Intn(10); n == 0 {
    fmt.Println("That's too low")
} else if n > 5 {
    fmt.Println("That's too big:", n)
} else {
    fmt.Println("That's a good number:", n)
}

#+end_src
*** for
- for-range's value is a copy
- complete for loop doesn’t properly handle multibyte characters, for-range do.

#+begin_src go
// complete for
for i := 0; i < 10; i++ {
    fmt.Println(i)

for i := 1; i <= 100; i++ {
    if i%3 == 0 && i%5 == 0 {
        fmt.Println("FizzBuzz")
        continue
    }
    if i%3 == 0 {
        fmt.Println("Fizz")
        continue
    }
    if i%5 == 0 {
        fmt.Println("Buzz")
        continue
    }
        fmt.Println(i)
}

// condition-only
i := 1
for i < 100 {
        fmt.Println(i)
        i = i * 2
}

// The Infinite for Statement
func main() {
	for {
		// things to do in the loop
		if !CONDITION {
			break
		}
	}
}

// for range

#+end_src
*** switch
- compare relatable values
- Favor blank switch statements over if/else chains when you have multiple related cases
- variable declaration at its head
- no fall through by default
- `fallthrough` keyword for one case continue on to the next one
- no parens after the switch word needed
- default branch spawn if no case matches.
- blank switchs:  do not specify the value to compare against, and it allows to use any boolean comparison

#+begin_src go
words := []string{"a", "cow", "smile", "gopher",
    "octopus", "anthropologist"}
for _, word := range words {
    switch size := len(word); size {
    case 1, 2, 3, 4:
        fmt.Println(word, "is a short word!")
    case 5:
        wordLen := len(word)
        fmt.Println(word, "is exactly the right length:", wordLen)
    case 6, 7, 8, 9:
    default:
        fmt.Println(word, "is a long word!")
    }
}

// blank switch

words := []string{"hi", "salutations", "hello"}
for _, word := range words {
    switch wordLen := len(word); {
    case wordLen < 5:
        fmt.Println(word, "is a short word!")
    case wordLen > 10:
        fmt.Println(word, "is a long word!")
    default:
        fmt.Println(word, "is exactly the right length.")
    }
}

#+end_src
*** goto
** Stop statement
*** continue
- labelled continue

#+begin_src go


// labelled continue
func main() {
    samples := []string{"hello", "apple_π!"}
outer:
    for _, sample := range samples {
        for i, r := range sample {
            fmt.Println(i, r, string(r))
            if r == 'l' {
                continue outer
            }
        }
        fmt.Println()
    }
}
#+end_src
*** break
** Const
- a way to give names to literals.
- there is no way in Go to declare that a variable is
- Numeric literals
- true and false
- Strings
- Runes
- The built-in functions complex, real, imag, len, and cap
- Expressions that consist of operators and the preceding values
- typed and untyped constants
- compiler allows you to create unread constants

#+begin_src go
const x int64 = 10

const (
    idKey   = "id"
    nameKey = "name"
)

const z = 20 * 10

func main() {
    const y = "hello"

    fmt.Println(x)
    fmt.Println(y)

    x = x + 1
    y = "bye"

    fmt.Println(x)
    fmt.Println(y)
}
#+end_src
** print
     #+begin_src go
     Printf("%#v\n", w) // # display values in a form similar to Go synVtax.
     #+end_src
** make
#+begin_src go
make([]T, len)
make([]T, len, cap) // same as make([]T, cap)[:len]
#+end_src
** mutex
     #+begin_src go emacs-lisp
     sync.Mutex
     #+end_src
** type
     #+begin_src go
     func (c Clear) String() string { // associates Clear to String
	     ...
     }

     #+end_src
** doc comment
     Extensive doc comments are often place d in a file of their own, convent ion ally cal le d doc.go
** pointers
     #+Begin_Src go

     func main() {
	     x = 1
	     ,*p = x
	     Printf(&p) // address of x
     }
     #+end_src
* Cli
** vet
      Examines Go source code and reports suspicious constructs

      |   |   |
      |---+---|
      |   |   |

** build
- build project and create binary
|                  |              |
|------------------+--------------|
| -o <name> <file> | set location |
|                  |              |

** get
      |   |   |
      |---+---|
      |   |   |

** install
|               |                            |
|---------------+----------------------------|
| <name>        |                            |
| <name>@latest | latest version of the tool |

#+begin_src shell

go install github.com/rakyll/hey@latest

#+end_src

** run
Run compiles and runs the named main Go package.

** env
- list golang environment variables
*** $GOPATH
*** $GOPROXY

* Standary Library
     #+begin_src go
     // end of line
     io.EOF

     #+end_src
* Terms
- runes: single characthers
* Packages
** tool
*** vet
vet is a tool for static analysis of Go programs.
** golangci-lint
** golint
     |       |                                  |
     |-------+----------------------------------|
     | ./... | runs golint over entire project. |
     |       |                                  |

** goimports
|              |                                                     |
|--------------+-----------------------------------------------------|
| -l <project> | list files whose formatting differs from goimport's |
| -w <project> | write result to (source) file instead of stdout     |
|              |                                                     |

#+begin_src shell-script
goimports -l -w .
#+end_src
