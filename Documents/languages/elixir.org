#+TILE: GNU Guile Language - Study Annotations

* Summary
  :PROPERTIES:
  :TOC:      :include all :depth 3 :ignore this
  :END:
:CONTENTS:
- [[#progress][Progress]]
  - [[#books][Books]]
  - [[#sloc][SLOC]]
  - [[#priorities][Priorities]]
- [[#features][Features]]
  - [[#type][Type]]
    - [[#atoms][atoms]]
    - [[#boolean][Boolean]]
    - [[#map][map]]
    - [[#binaries-and-bitstrings][Binaries and bitstrings]]
    - [[#strings-binary-strings][Strings (binary strings)]]
    - [[#character-lists][Character lists]]
    - [[#keyword][Keyword]]
    - [[#mapset][MapSet]]
    - [[#dates][Dates]]
    - [[#time][Time]]
    - [[#datetime][DateTime]]
    - [[#io-lists][IO lists]]
    - [[#typespec][Typespec]]
  - [[#operators][Operators]]
  - [[#macros][Macros]]
  - [[#beam][BEAM]]
    - [[#apply][Apply]]
  - [[#functions][Functions]]
    - [[#default-argument-values][default argument values]]
  - [[#lambdaanonymous-func][lambda/anonymous func]]
    - [[#-operator][& operator]]
- [[#packages][Packages]]
  - [[#elixir][elixir]]
  - [[#elixirc][elixirc]]
  - [[#eex][eex]]
  - [[#ex_unit][ex_unit]]
  - [[#iex][iex]]
  - [[#paths][Paths]]
  - [[#ex_doc][ex_doc]]
  - [[#phoenix][phoenix]]
  - [[#mix][mix]]
    - [[#format][format]]
- [[#tests][Tests]]
  - [[#rspec][RSpec]]
  - [[#unit][Unit]]
:END:
* Progress
** Books
   | Books                  | Chapter                  | @                                    | late | revision |
   |------------------------+--------------------------+--------------------------------------+------+----------|
   | Elixir in Action       | Building blocks          | Other built-in types                 |      |          |
   | Programming Elixir 1.6 | Conventional Programming | Ignoring a Value with _ (Underscore) |      |          |
   | Programming in Elixir  | Elixir Basics            |                                      |      |          |
** SLOC
   | Project   | folder | file | @ |
   |-----------+--------+------+---|
   | elixir    |        |      |   |
   | phoenix   |        |      |   |
   | elixir-ls |        |      |   |
** Priorities
   - Elixir
   - Phoenix
   - Unit Test
   - SOLID, KISS, YAGNI, DRY, Clean Code, Design Patterns
   - Git
   - HTML/CSS/JS
   - PostgreSQL
   - API REST { YAML, JSON, XML, SOAP }
   - CS
   - English
   - Container
   - Sidekiq
   - Heroku
   - Slim
   - CI/CD
   - Cloud

* Features
  | features     | example                              | desc   |
  |--------------+--------------------------------------+--------|
  | pin operator | ^                                    | forces |
  | ranges       | 1..100                               |        |
  | regex        | Regex.run ~r{[aeiou]}, "caterpillar" |        |

** Type
*** atoms
    #+begin_src elixir
    :an_atom
    #+end_src
***** aliases
      - aliases are atoms that begin with upcased: AnAtom
	-
*** Boolean
    - :true
    - :false
    - true, false are syntax sugar of those
*** map
    #+begin_src elixir
    x = %{1 => '1'}
    y = Map.new({1,'1'}, {2, '2'})

    y[1] # '1'

    Map.get(y, 1)
    Map.get(y, 3, :not_found) # returns `:not_found` as default value if index is no found

    Map.fetch(y, 1) # {:ok, '1'}
    Map.fetch(y, 3) # :error

    Map.put a, 4, '4'

    a = %{:name => 'boy', :age => 2}
    a = %{name: 'boy', age: 2} # shorter notation if keys are atom

    a[:name] #  'boy'
    a.name # 'boy'
    a.height # ** (KeyError) key :non_existent_field not found
    b = %{a | name: 'gota', age: 4}

    #+end_src
*** Binaries and bitstrings
    #+begin_src elixir
    <<1, 2, 3>>
    <<257::16>> # use 16bits
    <<1, 2>> <> <<3, 4>>
    #+end_src
*** Strings (binary strings)
    - printed as a string, but underneath it’s a binary

    #+begin_src elixir
    "Hello World"

    #
    "1 + 1 is equal #{1+1}"

    "String" <> " " <> "concatenation"

    #+end_src
**** conversion
     #+begin_src elixir
     List.to_string/1
     #+end_src
**** embedded string expressions
     #+begin_src elixir
     "1 + 1 is equal #{1+1}"
     #+end_src
**** sigils
     - ~S that doesn’t handle interpolation or escape characters
     #+begin_src elixir
     ~s(This is also a string)
     ~s(1 + 1 = #{3 + 0.14})

     ~S(Not interpolated #{3 + 0.14})
     #+end_src
**** heredocs
     #+begin_src elixir
     """
     Heredoc must end on its own line """
     """
     #+end_src
*** Character lists
    #+begin_src elixir
    'ABC'

    [65, 66, 67]

    ~c(Barri gota)
    ~C(Unescaped sigil #{3 + 0.14})

    '''
    Heredoc
    '''
    #+end_src
**** conversion
     #+begin_src elixir
     String.to_charlist("ABC")
     #+end_src
*** Keyword
    - a list, where each element is a two-element tuple, and the first element of each tuple is an atom. The second element can be of any type
    - often used for small-size key/value structures
    - can contain multiple values for the same key
    - can control the ordering of keyword list elements
    - many functions in standard libraries of Elixir and Erlang take their options as keyword lists.

      #+begin_src elixir
      [{:monday, 1}, {:tuesday, 2}, {:wednesday, 3}]
      [monday: 1, tuesday: 2, wednesday: 3]
      days[:tuesday]
      #+end_src
*** MapSet
    - store of unique values
     #+begin_src elixir
     MapSet.new([:monday, :tuesday, :wednesday])
     #+end_src

**** Functions
     #+begin_src elixir
     MapSet.member?(days, :monday)
     MapSet.put(days, :thursday)
     #+end_src
*** Dates
    - ~D sigil.
      #+begin_src elixir
      date = ~D[2018-01-31]
      date.year # 2018
      #+end_src

*** Time
    - ~T sigil
    #+begin_src elixir
    time = ~T[11:59:12.00007]
    time.hour
    #+end_src

*** DateTime
    #+begin_src elixir
    naive_datetime = ~N[2018-01-31 11:59:12.000007]
    naive_datetime.year
    datetime = DateTime.from_naive!(naive_datetime, "Etc/UTC")
    #+end_src

*** IO lists
    - useful for incrementally building output that will be forwarded to an I/O device, such as a network or a file.
    - Each element of an IO list must be: An integer in the range of 0 to 255, a binary, An IO list
    - Under the hood, the structure is flattened

      #+begin_src elixir
      iolist = [[['H', 'e'], "llo,"], " worl", "d!"]
      IO.puts(iolist)
      #+end_src

*** Typespec
    - type
    - opaque
    - typep
    - spec
    - callback
    - macrocallback
** Operators
   - many operators in Elixir are actually functions
   - atoms false and nil are treated as falsy
** Macros
** BEAM
*** Apply
    Dynamically call functions at runtime.
    #+begin_src elixir
    apply(IO, :puts, ["Dynamic function call."])
    #+end_src
** Functions
   - can be assigned to a variable

*** default argument values
    #+begin_src elixir
    def my_fun(arg1, arg2, opts \\ "foo")
    #+end_src
** lambda/anonymous func
   - can be assigned to a variable
   - can be argument of function
   - closure capts outside vars value
   - captures a specific memory location. Rebinding a variable doesn’t affect the previously defined lambda that references the same symbolic name
   #+begin_src elixir
   fn x -> IO.puts(x) end

   Enum.each(
     [1, 2, 3],
     fn x -> IO.puts(x) end
   )
   #+end_src
*** & operator
   - capture operator: &, turns that function into a lambda that can be assigned to a variable.
   - & operator can be used to shorten the lambda definition, making it possible to omit explicit argument naming.
     #+begin_src elixir
     Enum.each([1, 2, 3], &IO.puts/1)

     lambda = fn x, y, z -> x * y + z end # short version of is
     lambda = &(&1 * &2 + &3)
     lambda.(2, 3, 4)
     #+end_src
* Packages
** elixir
   |                    |                                                   |
   |--------------------+---------------------------------------------------|
   | --no-halt <script> | BEAM instance wont terminate after script is run |
   |                    |                                                   |

** elixirc
** eex
** ex_unit
** iex
   |               |               |                     |
   |---------------+---------------+---------------------|
   | h [<feature>] | h IO.puts     | help                |
   | i             |               | interactive         |
   | c <filepath>  | c 'hello.exs' | compile and execute |

** Paths
   add additional code paths by providing the -pa switch:
   #+begin_src elixir
   iex -pa my/code/path -pa another/code/path
   #+end_src

** ex_doc
** phoenix
** [[https://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html][mix]]
   | options                         | desc                       |
   +---------------------------------+----------------------------|
   | mix help deps                   |                            |
   | new <name> --module <Namespace> | new project named <name>   |
   | compile                         | compile the entire project |
   | run -e "<code>"                 |                            |
   | test                            |                            |

*** format

* Tests
** RSpec
** Unit
