#+TILE: Ruby Language - Study Annotations

* Summary
  :PROPERTIES:
  :TOC:      :include all :depth 3 :ignore this
  :END:
:CONTENTS:
- [[#progress][Progress]]
  - [[#books][Books]]
  - [[#sloc][SLOC]]
- [[#features][Features]]
  - [[#writable-object-attribute][writable object attribute]]
  - [[#global-variables][global variables]]
  - [[#self][self]]
  - [[#commentary][commentary]]
  - [[#defined][defined?]]
  - [[#iterators][iterators]]
  - [[#block-local-variables][block-local variables]]
  - [[#loops][loops]]
  - [[#statement-modifiers][statement modifiers]]
  - [[#comparison][comparison]]
  - [[#conditional][conditional]]
  - [[#class][class]]
  - [[#append-][append <<]]
  - [[#blocks][blocks]]
  - [[#lambda][lambda]]
    - [[#how][How]]
    - [[#usage][Usage]]
  - [[#methods][methods]]
  - [[#procs][procs]]
  - [[#operators][operators]]
  - [[#enumerable][enumerable]]
  - [[#enumerator][enumerator]]
    - [[#lazy][lazy]]
    - [[#each_car][each_car]]
    - [[#each][each]]
    - [[#to_enumenum_for][to_enum/enum_for]]
  - [[#inject][inject]]
  - [[#select][select]]
  - [[#succ][succ]]
  - [[#collect][collect]]
  - [[#freeze][freeze]]
  - [[#dup][dup]]
  - [[#dig][dig]]
  - [[#fetch][fetch]]
  - [[#tap][tap]]
  - [[#map][map]]
  - [[#pluck][pluck]]
  - [[#quoting][Quoting]]
  - [[#heredocs][heredocs]]
  - [[#proc][proc]]
  - [[#do-end-as-param][do end as param]]
  - [[#array][array]]
  - [[#datetime][date/time]]
  - [[#lambda][lambda]]
  - [[#begin-rescue][begin rescue]]
  - [[#hash][hash]]
  - [[#range][range]]
  - [[#sets][sets]]
  - [[#gsub][gsub]]
  - [[#find][find]]
  - [[#map][map]]
  - [[#each_slice][each_slice]]
  - [[#lazy][lazy]]
  - [[#with_index][with_index]]
  - [[#enum_for][enum_for]]
  - [[#more][more]]
  - [[#concepts][Concepts]]
    - [[#iterator][Iterator]]
    - [[#methods][Methods]]
    - [[#enumerator][Enumerator]]
  - [[#instructions][Instructions]]
    - [[#rbenv][Rbenv]]
- [[#tests][Tests]]
  - [[#rspec][RSpec]]
  - [[#unit][Unit]]
:END:
* Progress
** Books
   | Books                                                     | Capitulo                                       | em                                                       | tarde                          | revisao |
   |-----------------------------------------------------------+------------------------------------------------+----------------------------------------------------------+--------------------------------+---------|
   | Pragmatic Ruby (Pickaxe)                                  | Exceptions, catch, and throw                   |                                                          |                                |         |
   | Closure in Ruby                                           |                                                |                                                          |                                |         |
   | Practical Object-Oriented Design                          | Designing Classes with a Single Responsibility | 2.2.3 Determining If a Class Has a Single Responsibility |                                |         |
   | Design Patterns in Ruby                                   | Strategy                                       |                                                          |                                |         |
   | Pragmatic Build Awesome Command-Line Applications in Ruby |                                                |                                                          |                                |         |
   | The Well Grounded Rubyist                                 | 12  File and I/O operations                    |                                                          |                                |         |
   | Eloquent Ruby                                             | Chapter 8. Embrace Dynamic Typing              | Shorter Programs, But Not the Way You Think              | Spec: A Plethora of Assertions |         |

** SLOC
   | Project | folder          | file       | @ |
   |---------+-----------------+------------+---|
   | ruby    | lib/bundler/cli | install.rb |   |
* Features
** writable object attribute
   #+begin_src ruby
   class ProjectList
     def initialize
       @projects = []
     end
     def projects=(list)
       @projects = list.map(&:upcase)
     end
     def [](offset)
       @projects[offset]
     end
   end

   # store list of names in uppercase
   list = ProjectList.new
   list.projects = %w{ strip sand prime sand paint sand paint rub paint }
   list[3]   # => "SAND"
   list[4]   # => "PAINT"
   #+end_src

   - attribute-setting methods
** global variables
   #+begin_src ruby
   $? # return global status of last command
   #+end_src
** self
   - It does this to allow the method chaining in the line scores << 10 << 20 << 40 . Because each call to << returns the scores object, you can then call << again, passing in a new score.
** commentary
   #+begin_src ruby
   # one line commentary

   =begin
   multiline
   commentary
   =end
   #+end_src
** defined?
** iterators
   #+begin_src ruby
   3.times { p 'meh' } # easy to avoid fence-post and off-by-one errors

   9.downto(5) { p 'meh' }

   0.upto(9) { p 'meh' }

   0.step(12, 3) {|x| print x, " " }

   [ 1, 1, 2, 3, 5 ].each {|val| print val, " " }


   #+end_src
** block-local variables
   #+begin_src ruby
   square = "yes"
   total = 0
   [ 1, 2, 3 ].each do |val; square|
     square = val * val
     total += square
   end
   puts "Total = #{total}, square = #{square}"
   produces:
     Total = 14, square = yes
   #+end_src
** loops
   #+begin_src ruby
   # WHILE , UNTIL , and FOR loops are built into the language and do not introduce new scope;

   while line = gets
     # ...
   end

   until play_list.duration > 60
     play_list.add(song_list.pop)
   end

   # when an enumerator object runs out of values inside a loop , the loop will terminate cleanly.
   # newly local variables created in LOOP are not accessible outside the block
   loop do
     puts "#{short_enum.next} - #{long_enum.next}"
   end

   # not a ruby way, translated by ruby to x.each
   for song in playlist
     song.play
   end


   # NEXT skips to the end of the loop, effectively starting the next iteration
   # BREAKn

   i=0
   loop do
     i += 1
     next if i < 3
     print i
     break if i > 4 # If a conventional loop doesn’t execute a break , its value is nil .
   end

   # REDO repeats the current iteration of the loop from the start but without reevaluating
   # the condition or fetching the next element (in an iterator)
   while line = gets
     next if line =~ /^\s*#/   # skip comments
     break if line =~ /^END/   # stop at end

     # substitute stuff in backticks and try again
     redo if line.gsub!(/`(.*?)`/) { eval($1) }

     # process line ...
   end



   #+end_src
** statement modifiers
   if and unless Modifiers
   #+begin_src ruby
   puts "a = #{a}" if $DEBUG
   print total unless total.zero?
   a *= 2 while a < 100
   a -= 10 until a < 10
   #+end_src
** comparison
   #+begin_src ruby
   # ==
   # ===
   # <=>
   # =~
   # eql?
   # equal?
   # !=
   # !~
   #+end_src
** conditional
   #+begin_src ruby
   '11' || 11
   '11' or 11 # same precedence
   var ||= "default value" # assign a value to a variable only if that variable isn’t already set


   '11' && 11 # higher precedence
   '11' and 11

   !true
   not true
   #+end_src
** class
   #+begin_src ruby
   # frozen_string_literal: true

   require 'pathname'

   # Class Description
   class Meh # Class name in Camel Case
     attr_reader :lo, :fi #

     OUCH = 'asdasd' #

     def initialize(lo, fi)
       @lo = lo #
       @fi = fi #
     end

     def alfa # instance method
	@localVar = 1
     end

     def use_local_var # instance method
       @localVar
     end

     def self.zeta #
     end
   end

   Eija = Class.new #

   def Eija.beta # singleton
   end


   # superclass

   class Parent
   end
   class Child < Parent
   end

   Child.superclass # => Parent

   #
   #+end_src
** append <<
** blocks
   #+begin_src ruby

   #+end_src
** lambda
*** How
    #+begin_src ruby
    lambda { |params| ... } # form 1

    -> params { ... }  # form 2
    #+end_src
*** Usage
    #+begin_src ruby
    proc1 = -> arg { puts "In proc1 with #{arg}" }
    proc1.call "ant"

    def n_times(thing)
      lambda {|n| thing * n }
    end

    p1 = n_times(23)
    p1.call(3) # => 69
    #+end_src
** methods
   default values, splat args (described later on page 120), keyword args, and a block parameter
   #+begin_src ruby
   def splating(*rest)
     puts rest.each { |x| puts }
   end

   def split_apart(first, *, last) # get first and last args, ignore middle ones
   #+end_src
** procs
   #+begin_src ruby
   def pass_in_block(asdf, &block)
   end

   multiple_of_three = -> n { (n % 3).zero? }
   palindrome = -> n { n = n.to_s; n == n.reverse }

   p Integer
       .all
       .select(&multiple_of_three)
       .select(&palindrome)
       .first(10)

   a = Proc.new

   def initialize(name, &block) # initialize can receive proc object

   tc = TaxCalculator.new("Sales tax") {|amt| amt * 0.075 }
   tc.get_tax(100) # => "Sales tax on 100 = 7.5"
   #+end_src
   - if the last parameter in a method definition is prefixed with an ampersand, any associated block is converted to a Proc object, and that object is assigned to the parameter. This allows you to store the block for use later.
** operators
   #+begin_src ruby
   val.to_s =~ /3/
   #+end_src
** enumerable
   #+begin_src ruby

   # iterate over only those lines that end with a d
   File.open("ordinal").grep(/d$/) do |line|
     puts line
   end




   #+end_src
** enumerator
*** lazy
    #+begin_src ruby
    def Integer.all
      Enumerator.new do |yielder, n: 0|
	loop { yielder.yield(n += 1) }
      end.lazy
    end
    #+end_src
*** each_car
*** each
*** to_enum/enum_for
    #+begin_src ruby
    a = [ 1, 3, "cat" ]
    h = { dog: "canine", fox: "vulpine" }

    # Create Enumerators
    enum_a = a.to_enum
    enum_h = h.to_enum

    enum_a.next # 1
    enum_h.next # [:dog, "canine"]
    enum_a.next # 3
    enum_h.next # [:fox, "vulpine"]

    enum_a = a.each # create an Enumerator using an internal iterator
    #+end_src
** inject
   accumulate a value across the members of a collection
** select
** succ
   increments a string value
   #+begin_src ruby
   'e'.succ # f
   #+end_src
** collect
   #+begin_src ruby
   ["H", "A", "L"].collect {|x| x.succ } # => ["I", "B", "M"]
   #+end_src
** freeze
   #+begin_src ruby
   person1.freeze # prevent modifications to the object
   #+end_src
** dup
   #+begin_src ruby
   person1 = "Tim"
   person2 = person1.dup # not aliasing person1
   #+end_src
** dig
** fetch
** tap
** map
** pluck
** Quoting
   %char{text}
   #+begin_src ruby
   a = %q(a b c d)

   b = %Q(a b c)
   #+end_src
** heredocs
   #+begin_src ruby
   <<EOL

   EOL

   <<EOL.to_i * 10
   EOL

   <<'EOL'
   EOL

   <<-EOL
   EOL

   <<~EOL
   EOL

   [1,2, <<EO asdasd EO]

   a(false, <<EO asd... EO)
   #+end_src
** proc
   #+begin_src ruby

   #+end_src
** do end as param
   #+begin_src ruby
   x = (do  1 + 2 end)
   x = (do 'a' + 'b' end).join(',')
   #+end_src
** array
   #+begin_src ruby
   a = [1, ["a", "b"], 4]
   arr[1][0]
   [1,2][0]
   arr.dig(3,0) value_at, a[2,3] = ..
   a[2..3]
   a.slice()
   a.[]=(0, "first")
   a.[](2)
   a = %w(a b c)
   a= %W({a} b c)
   x.to_ary
   x.to_arr
   Array()
   def string.to_arr
   end
   a.unshift(0)
   a.push(1,2,3)
   a << 5
   a.pop
   a.shift
   a.concat
   a.replace([1,2,3])
   a.flatten
   a.reverse
   a.join(" , ")
   a = *
   a.uniq
   a.compact
   a.size
   a.empty
   a.include?
   a.first
   a.last
   a.sample # return
   a.count(1)
   #+end_src
   [[file:path]]
** date/time
   #+begin_src ruby
   require 'date'
   d = date.today

   require 'time'
   t = time.zxcz
   #+end_src
** lambda
   #+begin_src ruby
   l = -> { xx; aa }
   l = lambda do
     yield xx
   end
   #+end_src
** begin rescue
   #+begin_src ruby
   begin
     puts 'I am before the raise.'
     raise 'An error has occured.'
     puts 'I am after the raise.'
   rescue
     puts 'I am rescued.'
   end
   #+end_src
** hash
   #+begin_src ruby
   h = Hash.new
   h = { one: 1, :two => 2 }
   h = Hash[1, "one", 2, "two"]
   h["1"] = 1
   h.[]=("New York", "NY")
   h.store("New York", "NY")
   a.update(b)
   a.merge(b)
   h.select {k,vk > 1 } !
   h.reject {  k,v  k > 1 } !
   h.reject! {  k,v  k > 1 }
   h = { street: "127th Street", apt: nil }.compact !
   h = { street: "127th Street", apt: nil }.compact!
   h.invert
   h.clear
   h = {...}.replace({...})
   h.key?
   h.empty?
   #+end_src
** range
   #+begin_src ruby
   r = Range.new(1,100)
   r = Range.new(1,100, true)
   r =  1..99(inclusive) r = 1...199(exclusive)
   r.cover? 2
   r.include? 3
   #+end_src
** sets
   #+begin_src ruby
   s = Set.new(array)
   s = Set.new(names) {name name.upcase }
   s << 5
   s.add 5
   s.delete(1)
   s.intersection|&| x
   s.union x
   s + x
   s.difference x
   s - x
   s ^ x
   s.merge [2]
   s.subset? b
   s.superset? b
   s.proper_subset? x
   s.proper_superset? x
   #+end_src
** gsub
   Returns a copy of str with all occurrences of pattern substituted for the second argument.                                                                                                                                                                                                                                                                                                                              |
** find
   #+begin_src ruby
   a.find { ¦n¦ n > 5 }
   a.find { ¦n¦ n > 5 }
   a.find_all
   a.select
   a.reject
   a.map
   #+end_src
** map
   #+begin_src ruby
   a.map { |x| x.uppercase}
   a.map! { |x| x.uppercase}
   #+end_src
** each_slice
   #+begin_src ruby
   animals.each_slice(2).map do |predator, prey|
   #+end_src
** lazy
   #+begin_src ruby
   (1..Float::INFINITY).lazy.select {|n| n % 3 == 0 }
   #+end_src
** with_index
   #+begin_src ruby
   ['a'..'z').map.with_index {|letter,i| [letter, i] } // Output: [["a", 0], ["b", 1], etc.]
   my_enum.take(5).force // actual result rather than lazy enumerator
   #+end_src
** enum_for
   #+begin_src ruby
   e = names.enum_for(:inject, "Names: ")
   #+end_src
** more
   |                        |                                                                                                           |                                                                                                             |
   |------------------------+-----------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------|
   | drop_while             | a.drop_while { true }                                                                                     |                                                                                                             |
   | take_while             | a.take_while { true }                                                                                     |                                                                                                             |
   | find_all               | a.find_all ¦ a.select                                                                                     |                                                                                                             |
   | reject                 | a.reject { ¦i¦ i > 4 } ¦ a.reject! { ¦i¦ i > 4 }                                                          |                                                                                                             |
   | select                 |                                                                                                           |                                                                                                             |
   | grep                   | a.grep(//o//) ¦ a.grep(String) ¦ a.grep(50..100) ¦                                                          |                                                                                                             |
   | group_by               | a.group_by { ¦s¦ s.size }                                                                                 |                                                                                                             |
   | match                  | //n//.match(s)                                                                                              |                                                                                                             |
   | String                 | 'C'.size ¦ each_byte ¦ each_line ¦ each_codepoint ¦ each_char ¦ s.bytes ¦                                 |                                                                                                             |
   | min/min_by             | a.min { ¦a,b¦ a.size <=> b.size } ¦  a.min { ¦lang¦ lang.size } ¦ state_hash.min_by { ¦name, abbr¦ name } |                                                                                                             |
   | max/max_by             |                                                                                                           |                                                                                                             |
   | minmax/minmax_by       | a.minmax ¦ a.minmax_by { ¦lang¦ lang.size }                                                               |                                                                                                             |
   | reverse_each           | [1,2,3].reverse_each { ¦e¦ puts e * 10 }                                                                  |                                                                                                             |
   | with_index             | letters.each.with_index {¦(key,value),i¦ puts i }                                                         |                                                                                                             |
   | each_index             | names.each.with_index(1) { ¦pres, i¦ p i }                                                                |                                                                                                             |
   | each_slice             |                                                                                                           |                                                                                                             |
   | each_cons              |                                                                                                           |                                                                                                             |
   | slice_before           | a.slice_before(\/=/).to_a ¦ (1..10).slice_before { ¦num¦ num % 2 == 0 }.to_a ¦                            |                                                                                                             |
   | slice_after            |                                                                                                           |                                                                                                             |
   | slice_when             | a.slice_when { ¦i,j¦ i == j }.to_a                                                                        |                                                                                                             |
   | inject/reduce          | [1,2,3,4].inject(:+)                                                                                      |                                                                                                             |
   | cycle                  |                                                                                                           |                                                                                                             |
   | map                    | names.map { ¦name¦ name.upcase } ¦  x = 5.times.map { Apple.new(rand(100..900)) }                         |                                                                                                             |
   | map!                   |                                                                                                           |                                                                                                             |
   | symbol-argument blocks | names.map(&:upcase)                                                                                       |                                                                                                             |
   | <=>                    | Apple#<=> ¦ Apple.sort { ¦a,b¦ a.brand <=> b.brand } ¦                                                    | implementing a spaceship test method is enough to sort a class, or use a block to sort, or even override it |
   | comparable             | Apple#<=> ¦                                                                                               | include comparable                                                                                          |
   | clamp                  |                                                                                                           |                                                                                                             |
   | between                |                                                                                                           |                                                                                                             |
   | functions              | -> (args) {} ¦ Sum = -> (a, b) { a + b }                                                                  |                                                                                                             |
   | <<                     | yielder                                                                                                   |                                                                                                             |
   |                        | enum_for                                                                                                  |                                                                                                             |
   |                        | to_enum                                                                                                   |                                                                                                             |
   | dup                    |                                                                                                           |                                                                                                             |
   |------------------------+-----------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------|
** Concepts
*** Iterator
    - is a method
    - it start and finish in the same call
*** Methods
**** Methods chaining
     creates a new object at it chains
     #+begin_src ruby
     puts animals.select {¦n¦ n[0] < 'M' }.map(&:upcase).join(", ")
     #+end_src
*** Enumerator
    - is an object
    - chaining
    - block based
    - method attachment (enum_for)
    - un-overriding of methods in Enumerable
    - maintain state
    - is an enumerable object
    - can add enumerability to objects
    - can stop and resume collection cycling
** Instructions
*** Rbenv
    rbenv global 2.3.0 && rbenv rehash
* Tests
** RSpec
** Unit
