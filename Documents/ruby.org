#+TILE: Ruby Language - Study Annotations

* Summary
  :PROPERTIES:
  :TOC:      :include all :depth 3 :ignore this
  :END:
:CONTENTS:
- [[#progress][Progress]]
  - [[#books][Books]]
  - [[#sloc][SLOC]]
- [[#packages][Packages]]
  - [[#gem][gem]]
  - [[#bundle][bundle]]
    - [[#outdated][outdated]]
    - [[#gem][gem]]
    - [[#install][install]]
    - [[#update][update]]
  - [[#irb][irb]]
  - [[#rspec][rspec]]
  - [[#unit-test][unit test]]
  - [[#pry][pry]]
- [[#features][Features]]
  - [[#project-structure][project structure]]
  - [[#system-errors][System Errors]]
    - [[#usage][usage]]
  - [[#exceptions][exceptions]]
    - [[#errors][Errors]]
    - [[#usage][usage]]
  - [[#writable-object-attribute][writable object attribute]]
  - [[#multithreading][Multithreading]]
    - [[#usage][usage]]
  - [[#modules][modules]]
  - [[#continuation][continuation]]
  - [[#fibers][Fibers]]
    - [[#errors][errors]]
    - [[#usage][usage]]
  - [[#delimited-input][delimited input]]
  - [[#rake][rake]]
    - [[#usage][usage]]
  - [[#gem][gem]]
  - [[#variables][Variables]]
    - [[#class-variables][class variables]]
    - [[#global-variables][global variables]]
  - [[#self][self]]
  - [[#commentary][commentary]]
  - [[#defined][defined?]]
  - [[#iterators][iterators]]
  - [[#block-local-variables][block-local variables]]
  - [[#loops][loops]]
  - [[#statement-modifiers][statement modifiers]]
  - [[#comparison][comparison]]
  - [[#conditional][conditional]]
  - [[#class][class]]
    - [[#class][class]]
  - [[#append-][append <<]]
  - [[#blocks][blocks]]
  - [[#lambda][lambda]]
    - [[#how][How]]
    - [[#usage][Usage]]
  - [[#methods][methods]]
  - [[#yield][yield]]
  - [[#procs][procs]]
  - [[#operators][operators]]
  - [[#enumerable][enumerable]]
  - [[#enumerator][enumerator]]
    - [[#lazy][lazy]]
    - [[#each_car][each_car]]
    - [[#each][each]]
    - [[#to_enumenum_for][to_enum/enum_for]]
  - [[#inject][inject]]
  - [[#select][select]]
  - [[#succ][succ]]
  - [[#collect][collect]]
  - [[#freeze][freeze]]
  - [[#dup][dup]]
  - [[#dig][dig]]
  - [[#fetch][fetch]]
  - [[#tap][tap]]
  - [[#map][map]]
  - [[#pluck][pluck]]
  - [[#quoting][Quoting]]
  - [[#here-documents][here documents]]
  - [[#proc][proc]]
  - [[#do-end-as-param][do end as param]]
  - [[#array][array]]
  - [[#datetime][date/time]]
  - [[#lambda][lambda]]
  - [[#begin-rescue][begin rescue]]
  - [[#hash][hash]]
  - [[#range][range]]
  - [[#sets][sets]]
  - [[#gsub][gsub]]
  - [[#find][find]]
  - [[#map][map]]
  - [[#each_slice][each_slice]]
  - [[#lazy][lazy]]
  - [[#with_index][with_index]]
  - [[#enum_for][enum_for]]
  - [[#more][more]]
  - [[#concepts][Concepts]]
    - [[#iterator][Iterator]]
    - [[#methods][Methods]]
    - [[#enumerator][Enumerator]]
  - [[#instructions][Instructions]]
    - [[#rbenv][Rbenv]]
    - [[#misc][misc]]
- [[#toolings][Toolings]]
- [[#videos][Videos]]
- [[#tests][Tests]]
  - [[#rspec][RSpec]]
  - [[#unit][Unit]]
:END:
* Progress
** Books
   | Books                            | Chapter                           | @                                           | late                           | revision                                      |
   |----------------------------------+-----------------------------------+---------------------------------------------+--------------------------------+-----------------------------------------------|
   | Pragmatic Ruby (Pickaxe)         | 22. The Ruby language             | Duck Typing/Numeric Coercion                | Names                          | Fibers, Threads, and Processes/Multithreading |
   | Practical Object-Oriented Design | Creating Flexible Interfaces      | 4.3.3 Using Sequence Diagrams               |                                |                                               |
   | Design Patterns in Ruby          | Template Method                   |                                             |                                |                                               |
   | Eloquent Ruby                    | Chapter 8. Embrace Dynamic Typing | Shorter Programs, But Not the Way You Think | Spec: A Plethora of Assertions |                                               |
   | Clean Ruby                       | Using Boolean Logic               |                                             |                                |                                               |
   | Closure in Ruby                  |                                   |                                             |                                |                                               |
   | Build Awesome Cli apps           | Easy to use                       | Documenting a Command Suite                 |                                |                                               |
   | The Well Grounded Rubyist        | 12  File and I/O operations       |                                             |                                |                                               |

** SLOC
   | Project | folder   | file           | @                     |
   |---------+----------+----------------+-----------------------|
   | rake    | lib/rake | application.rb | display_cause_details |

* Packages
** gem
   |                             |   |
   |-----------------------------+---|
   | install <name> -v <version> |   |
   | which                       |   |
   | list                        |   |
   | search                      |   |
   | env                         |   |
   | info <name>                 |   |

** bundle
*** outdated
*** gem
    |                   |   |
    |-------------------+---|
    | list              |   |
    | which <name>      |   |
    | gem search <name> |   |

*** install
*** update
    | subcommand                  | desc                                                       |
    |-----------------------------+------------------------------------------------------------|
    | all                         | update all gems                                            |
    | --group=<name>, -g=[<name>] | Only update the gems in the specified group.               |
    | --source=<name>             | The name of a :git or :path source used in the Gemfile(5). |
    | --quiet                     |                                                            |
    | --redownload                |                                                            |
    | --minor                     | Prefer updating only to next minor version.                |
    | --major                     | Prefer updating to next major version (default).           |
    |                             |                                                            |
** irb
** rspec
   - RSpec.describe
   - describe
   - context
   - it ''
   - expect().to
   - before(:xx)
   - after(:xxx)
   - before(:context)
   - after(:context)
   - let(:aaa) { asdasd }
** unit test
** pry
* Features
** project structure
   #+begin_src ruby
   anagram/    <- top-level
     bin/      <- command-line interface goes here
     lib/      <- three library files go here
     test/     <- test files go here
   #+end_src
** System Errors
   - SystemCallError
   - subclasses are defined in a module called Errno
*** usage
    #+begin_src ruby
    Errno::EAGAIN
    Errno::EIO
    Errno::EPERM

    Errno::EAGAIN::Errno # => 35, same error number as EWOULDBLOCK, can be interchangeable
    Errno::EPERM::Errno # => 1
    Errno::EWOULDBLOCK::Errno # => 35
    #+end_src
** exceptions
   - class *Exception*
   - Custom exceptions subclasses of StandardError or its children.
   - Exception has an associated message string and a stack backtrace.
   - Custom exceptions can add extra information
   - rescue matches thrown Exception and use it. Similar to case statement
   - rescue clause with no parameter list, the parameter defaults to StandardError .
   - rescue clause can be arbitrary expressions (including method calls) that return an Exception class.
*** Errors
    - StandardError
    -
*** usage
    #+begin_src ruby

    # Exception skeleton

    f = File.open("/a/file")
    begin
    # .....
    rescue Exception
      if @esmtp then
	@esmtp = false
	retry # repeat the entire begin / end block
      else
	raise # reraise the exception. FAIL is similar
      end
    else # after RESCUE and before any ENSURE, is executed only if no exceptions are raised by the main body of code.
      puts "Congratulations-- no errors!"
    ensure
      f.close
    end

    # At the end of each rescue clause, you can give Ruby the name
    # of a local variable to receive the matched exception.
    begin
      eval string
    rescue SyntaxError, NameError => boom
      print "String doesn't compile: " + boom
    rescue StandardError => bang
      print "Error running script: " + bang
    end

    # reraises the current exception (or a RuntimeError if there is no current exception).
    # This is used in exception handlers that intercept an exception before passing it on.
    raise

    # Creates a new RuntimeError exception, setting its message to the given string.
    raise "bad mp3 encoding" #

    # first argument to create an exception and then sets the associated
    # message to the second argument and the stack trace to the third argument.
    raise InterfaceException, "Keyboard failure", caller

    raise

    raise "Missing name" if name.nil?

    if i >= names.size
      raise IndexError, "#{i} >= size (#{names.size})"
    end

    raise ArgumentError, "Name too big", caller

    # removes two routines from the backtrace
    # by passing only a subset of the call stack to the new exception:
    raise ArgumentError, "Name too big", caller[1..-1]
    #+end_src
** writable object attribute
   #+begin_src ruby
   class ProjectList
     def initialize
       @projects = []
     end
     def projects=(list)
       @projects = list.map(&:upcase)
     end
     def [](offset)
       @projects[offset]
     end
   end

   # store list of names in uppercase
   list = ProjectList.new
   list.projects = %w{ strip sand prime sand paint sand paint rub paint }
   list[3]   # => "SAND"
   list[4]   # => "PAINT"
   #+end_src

   - attribute-setting methods
** Multithreading
   -
*** usage
** modules
   #+begin_src ruby

   module A
     module_function

     def foo
     end
   end

   module A
     module SubA
       def bar
       end
     end
   end


   A::foo
   A::SubA:bar
   #+end_src
** continuation
   - require 'continuation'

** Fibers
   - no require
   - resume
   - yield
   - require: requiring `fiber library` gives additional `transfer` methods
*** errors
    - FiberError: calling resume after last fiber returned `nil`
*** usage
    #+begin_src ruby


    twos = Fiber.new do
      num = 2
      loop do
	Fiber.yield(num) unless num % 3 == 0
	num += 2
      end
    end

    10.times { print twos.resume, " " }
    #+end_src
** delimited input
   #+begin_src ruby
   # %q - Single-quoted string
   %q{\a and #{1+2} are literal}

   # %Q, % - Double-quoted string
   %Q{\a and #{1+2} are expanded}

   # %w, %W - Array of strings
   %w[ one two three ]

   # %i, %I -  Array of symbols
   %i[ one two three ]

   # %r - Regular expression pattern
   %r{cat|dog}

   # %s - A symbol
   %s!a symbol!

   # %x, `` - Shell command
   %x(df -h)

   #+end_src
** rake
   - -T: list avaiable tasks
   - spec: run spec tests

*** usage
    #+begin_src ruby
    # desc:
    # task:

    desc "Remove Unix and Windows backup files"
    task :delete_backups => [ :delete_unix_backups, :delete_windows_backups ] do # depends on two other tasks
      puts "All backups deleted"
    end
    #+end_src

** gem
   gem build GEM.gemspec
   gem install --user-install pkg/GEM
   gem list GEM -d

** Variables

*** class variables
    - available throughout a class or module body
    - must be initialized before use
    - is shared among all instances of a class and is available within the class itself.

*** global variables
    - available throughout a program.
    - references to it returns the same object.
    - referencing an uninitialized global variable returns nil.

    #+begin_src ruby
    $? # return global status of last command
    #+end_src
** self
   - is a keyword
   - It does this to allow the method chaining in the line scores << 10 << 20 << 40 . Because each call to << returns the scores object, you can then call << again, passing in a new score.

     #+begin_src ruby

     class tea
       def self.drink () # Class-Level method (static)
	 puts 'drinking'
       end

       def meh
	 puts self # refers to tea class
       end

       def builder

	 self # return class
       end
     end
     #+end_src
** commentary
   #+begin_src ruby
   # one line commentary

   =begin
   multiline
   commentary
   =end
   #+end_src
** defined?
** iterators
   #+begin_src ruby
   3.times { p 'meh' } # easy to avoid fence-post and off-by-one errors

   9.downto(5) { p 'meh' }

   0.upto(9) { p 'meh' }

   0.step(12, 3) {|x| print x, " " }

   [ 1, 1, 2, 3, 5 ].each {|val| print val, " " }


   #+end_src
** block-local variables
   #+begin_src ruby
   square = "yes"
   total = 0
   [ 1, 2, 3 ].each do |val; square|
     square = val * val
     total += square
   end
   puts "Total = #{total}, square = #{square}"
   produces:
     Total = 14, square = yes
   #+end_src
** loops
   #+begin_src ruby
   # WHILE , UNTIL , and FOR loops are built into the language and do not introduce new scope;

   while line = gets
     # ...
   end

   until play_list.duration > 60
     play_list.add(song_list.pop)
   end

   # when an enumerator object runs out of values inside a loop , the loop will terminate cleanly.
   # newly local variables created in LOOP are not accessible outside the block
   loop do
     puts "#{short_enum.next} - #{long_enum.next}"
   end

   # not a ruby way, translated by ruby to x.each
   for song in playlist
     song.play
   end


   # NEXT skips to the end of the loop, effectively starting the next iteration
   # BREAKn

   i=0
   loop do
     i += 1
     next if i < 3
     print i
     break if i > 4 # If a conventional loop doesn’t execute a break , its value is nil .
   end

   # REDO repeats the current iteration of the loop from the start but without reevaluating
   # the condition or fetching the next element (in an iterator)
   while line = gets
     next if line =~ /^\s*#/   # skip comments
     break if line =~ /^END/   # stop at end

     # substitute stuff in backticks and try again
     redo if line.gsub!(/`(.*?)`/) { eval($1) }

     # process line ...
   end



   #+end_src
** statement modifiers
   if and unless Modifiers
   #+begin_src ruby
   puts "a = #{a}" if $DEBUG
   print total unless total.zero?
   a *= 2 while a < 100
   a -= 10 until a < 10
   #+end_src
** comparison
   #+begin_src ruby
   # ==
   # ===
   # <=>
   # =~
   # eql?
   # equal?
   # !=
   # !~
   #+end_src
** conditional
   #+begin_src ruby
   '11' || 11
   '11' or 11 # same precedence
   var ||= "default value" # assign a value to a variable only if that variable isn’t already set


   '11' && 11 # higher precedence
   '11' and 11

   !true
   not true
   #+end_src
** class
   - :: is Ruby’s namespace resolution operator.
   - Math::PI - access Math PI variable
   - Math.sin(Math::PI/6.0) - access Math sin method
   - Names of classes and modules are just constants.
   - can nest classes and modules inside other classes and modules to any depth

*** class
    #+begin_src ruby
    # frozen_string_literal: true

    require 'pathname'

    # Class Description
    class Meh # Class name in Camel Case
      OUCH = 'asdasd' # 1
      attr_reader :lo, :fi # 2

      # static method
      def self.from_file(file_name) # 3
	new(File.readlines(file_name))
      end

      def initialize(lo, fi) # 4
	@alpha = OUCH
	@lo = lo #
	@fi = fi #
      end

      private_class_method :new

      private

      def alfa # instance method
	@localVar = 1
      end

      def use_local_var # instance method
	@localVar
      end

      def self.zeta #
      end
    end

    Eija = Class.new #

    def Eija.beta # singleton
    end


    # superclass

    class Parent
    end
    class Child < Parent
    end

    Child.superclass # => Parent

    #

    #
    #+end_src
** append <<
** blocks
   #+begin_src ruby

   #+end_src
** lambda
*** How
    #+begin_src ruby
    lambda { |params| ... } # form 1

    -> params { ... }  # form 2
    #+end_src
*** Usage
    #+begin_src ruby
    proc1 = -> arg { puts "In proc1 with #{arg}" }
    proc1.call "ant"

    def n_times(thing)
      lambda {|n| thing * n }
    end

    p1 = n_times(23)
    p1.call(3) # => 69
    #+end_src
** methods
   default values, splat args (described later on page 120), keyword args, and a block parameter
   #+begin_src ruby
   def splating(*rest)
     puts rest.each { |x| puts }
   end

   def split_apart(first, *, last) # get first and last args, ignore middle ones
   #+end_src
** yield
   #+begin_src ruby

   def foo
     yield
   end

   def bar
     if block_given?
       yield
     else
       'lol'
   end

   foo { p 'meh' }
   bar # => lol
   bar { p 'yahoo' } # => yahoo
   #+end_src
** procs
   #+begin_src ruby
   def pass_in_block(asdf, &block)
   end

   multiple_of_three = -> n { (n % 3).zero? }
   palindrome = -> n { n = n.to_s; n == n.reverse }

   p Integer
       .all
       .select(&multiple_of_three)
       .select(&palindrome)
       .first(10)

   a = Proc.new

   def initialize(name, &block) # initialize can receive proc object

   tc = TaxCalculator.new("Sales tax") {|amt| amt * 0.075 }
   tc.get_tax(100) # => "Sales tax on 100 = 7.5"
   #+end_src
   - if the last parameter in a method definition is prefixed with an ampersand, any associated block is converted to a Proc object, and that object is assigned to the parameter. This allows you to store the block for use later.
** operators
   #+begin_src ruby
   val.to_s =~ /3/
   #+end_src
** enumerable
   #+begin_src ruby

   # iterate over only those lines that end with a d
   File.open("ordinal").grep(/d$/) do |line|
     puts line
   end




   #+end_src
** enumerator
*** lazy
    #+begin_src ruby
    def Integer.all
      Enumerator.new do |yielder, n: 0|
	loop { yielder.yield(n += 1) }
      end.lazy
    end
    #+end_src
*** each_car
*** each
*** to_enum/enum_for
    #+begin_src ruby
    a = [ 1, 3, "cat" ]
    h = { dog: "canine", fox: "vulpine" }

    # Create Enumerators
    enum_a = a.to_enum
    enum_h = h.to_enum

    enum_a.next # 1
    enum_h.next # [:dog, "canine"]
    enum_a.next # 3
    enum_h.next # [:fox, "vulpine"]

    enum_a = a.each # create an Enumerator using an internal iterator
    #+end_src
** inject
   accumulate a value across the members of a collection
** select
** succ
   increments a string value
   #+begin_src ruby
   'e'.succ # f
   #+end_src
** collect
   #+begin_src ruby
   ["H", "A", "L"].collect {|x| x.succ } # => ["I", "B", "M"]
   #+end_src
** freeze
   #+begin_src ruby
   person1.freeze # prevent modifications to the object
   #+end_src
** dup
   #+begin_src ruby
   person1 = "Tim"
   person2 = person1.dup # not aliasing person1
   #+end_src
** dig
** fetch
** tap
** map
** pluck
** Quoting
   %char{text}
   #+begin_src ruby
   a = %q(a b c d)

   b = %Q(a b c)
   #+end_src
** here documents
   #+begin_src ruby
   <<EOL # double quote document
      \n
   #{Time.now}
   EOL

   <<EOL.to_i * 10
   EOL

   <<'EOL' # single quote document
      \n
   #{Time.now}
   EOL

   <<-EOL
   EOL

   <<~EOL
   EOL

   [1,2, <<EO asdasd EO]

   a(false, <<EO asd... EO)
   #+end_src
** proc
   #+begin_src ruby

   #+end_src
** do end as param
   #+begin_src ruby
   x = (do  1 + 2 end)
   x = (do 'a' + 'b' end).join(',')
   #+end_src
** array
   #+begin_src ruby
   # creation
   a = [1, ["a", "b"], 4]
   a = Array.new(1,2)
   a = arr = %w( Hey!\tIt is now -#{Time.now}- )


   # indexing
   arr[1][0]
   [1,2][0]
   arr.dig(3,0) value_at, a[2,3] = ..
   a[2..3]
   a.slice()
   a.[]=(0, "first")
   a.[](2)
   a = %w(a b c)
   a= %W({a} b c)
   x.to_ary
   x.to_arr
   Array()
   def string.to_arr
   end
   a.unshift(0)
   a.push(1,2,3)
   a << 5
   a.pop
   a.shift
   a.concat
   a.replace([1,2,3])
   a.flatten
   a.reverse
   a.join(" , ")
   a = *
   a.uniq
   a.compact
   a.size
   a.empty
   a.include?
   a.first
   a.last
   a.sample # return
   a.count(1)
   #+end_src
   [[file:path]]
** date/time
   #+begin_src ruby
   require 'date'
   d = date.today

   require 'time'
   t = time.zxcz
   #+end_src
** lambda
   #+begin_src ruby
   l = -> { xx; aa }
   l = lambda do
     yield xx
   end
   #+end_src
** begin rescue
   #+begin_src ruby
   begin
     puts 'I am before the raise.'
     raise 'An error has occured.'
     puts 'I am after the raise.'
   rescue
     puts 'I am rescued.'
   end
   #+end_src
** hash
   #+begin_src ruby
   h = Hash.new
   h = { one: 1, :two => 2 }
   h = Hash[1, "one", 2, "two"]

   h.rehash # force the hash to be reindexed


   h["1"] = 1
   h.[]=("New York", "NY")
   h.store("New York", "NY")
   a.update(b)
   a.merge(b)
   h.select {k,vk > 1 } !
   h.reject {  k,v  k > 1 } !
   h.reject! {  k,v  k > 1 }
   h = { street: "127th Street", apt: nil }.compact !
   h = { street: "127th Street", apt: nil }.compact!
   h.invert
   h.clear
   h = {...}.replace({...})
   h.key?
   h.empty?
   #+end_src
** range
   #+begin_src ruby
   # create a new range object
   r = 1..2

   # include all elements
   r =  1..99

   # exclude last element
   r = 1...199

   # verbose object creation
   r = Range.new(1,100)
   r = Range.new(1,100, true)

   # methods
   r.cover? 2
   r.include? 3
   r.max
   r.reject {}
   r.inject {}

   # range of object need to return the next object `succ` and be comparable <=>

   # ranges as conditions
   while line = gets
     puts line if line =~ /start/ .. line =~ /end/
   end

   # ranges as intervals
   (1..10) === 5   # => true
   (1..10) === 15  # => false





   #+end_src
** sets
   #+begin_src ruby
   s = Set.new(array)
   s = Set.new(names) {name name.upcase }
   s << 5
   s.add 5
   s.delete(1)
   s.intersection|&| x
   s.union x
   s + x
   s.difference x
   s - x
   s ^ x
   s.merge [2]
   s.subset? b
   s.superset? b
   s.proper_subset? x
   s.proper_superset? x
   #+end_src
** gsub
   Returns a copy of str with all occurrences of pattern substituted for the second argument.                                                                                                                                                                                                                                                                                                                              |
** find
   #+begin_src ruby
   a.find { ¦n¦ n > 5 }
   a.find { ¦n¦ n > 5 }
   a.find_all
   a.select
   a.reject
   a.map
   #+end_src
** map
   #+begin_src ruby
   a.map { |x| x.uppercase}
   a.map! { |x| x.uppercase}
   #+end_src
** each_slice
   #+begin_src ruby
   animals.each_slice(2).map do |predator, prey|
   #+end_src
** lazy
   #+begin_src ruby
   (1..Float::INFINITY).lazy.select {|n| n % 3 == 0 }
   #+end_src
** with_index
   #+begin_src ruby
   ['a'..'z').map.with_index {|letter,i| [letter, i] } // Output: [["a", 0], ["b", 1], etc.]
   my_enum.take(5).force // actual result rather than lazy enumerator
   #+end_src
** enum_for
   #+begin_src ruby
   e = names.enum_for(:inject, "Names: ")
   #+end_src
** more
   |                        |                                                                                                           |                                                                                                             |
   |------------------------+-----------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------|
   | drop_while             | a.drop_while { true }                                                                                     |                                                                                                             |
   | take_while             | a.take_while { true }                                                                                     |                                                                                                             |
   | find_all               | a.find_all ¦ a.select                                                                                     |                                                                                                             |
   | reject                 | a.reject { ¦i¦ i > 4 } ¦ a.reject! { ¦i¦ i > 4 }                                                          |                                                                                                             |
   | select                 |                                                                                                           |                                                                                                             |
   | grep                   | a.grep(//o//) ¦ a.grep(String) ¦ a.grep(50..100) ¦                                                          |                                                                                                             |
   | group_by               | a.group_by { ¦s¦ s.size }                                                                                 |                                                                                                             |
   | match                  | //n//.match(s)                                                                                              |                                                                                                             |
   | String                 | 'C'.size ¦ each_byte ¦ each_line ¦ each_codepoint ¦ each_char ¦ s.bytes ¦                                 |                                                                                                             |
   | min/min_by             | a.min { ¦a,b¦ a.size <=> b.size } ¦  a.min { ¦lang¦ lang.size } ¦ state_hash.min_by { ¦name, abbr¦ name } |                                                                                                             |
   | max/max_by             |                                                                                                           |                                                                                                             |
   | minmax/minmax_by       | a.minmax ¦ a.minmax_by { ¦lang¦ lang.size }                                                               |                                                                                                             |
   | reverse_each           | [1,2,3].reverse_each { ¦e¦ puts e * 10 }                                                                  |                                                                                                             |
   | with_index             | letters.each.with_index {¦(key,value),i¦ puts i }                                                         |                                                                                                             |
   | each_index             | names.each.with_index(1) { ¦pres, i¦ p i }                                                                |                                                                                                             |
   | each_slice             |                                                                                                           |                                                                                                             |
   | each_cons              |                                                                                                           |                                                                                                             |
   | slice_before           | a.slice_before(\/=/).to_a ¦ (1..10).slice_before { ¦num¦ num % 2 == 0 }.to_a ¦                            |                                                                                                             |
   | slice_after            |                                                                                                           |                                                                                                             |
   | slice_when             | a.slice_when { ¦i,j¦ i == j }.to_a                                                                        |                                                                                                             |
   | inject/reduce          | [1,2,3,4].inject(:+)                                                                                      |                                                                                                             |
   | cycle                  |                                                                                                           |                                                                                                             |
   | map                    | names.map { ¦name¦ name.upcase } ¦  x = 5.times.map { Apple.new(rand(100..900)) }                         |                                                                                                             |
   | map!                   |                                                                                                           |                                                                                                             |
   | symbol-argument blocks | names.map(&:upcase)                                                                                       |                                                                                                             |
   | <=>                    | Apple#<=> ¦ Apple.sort { ¦a,b¦ a.brand <=> b.brand } ¦                                                    | implementing a spaceship test method is enough to sort a class, or use a block to sort, or even override it |
   | comparable             | Apple#<=> ¦                                                                                               | include comparable                                                                                          |
   | clamp                  |                                                                                                           |                                                                                                             |
   | between                |                                                                                                           |                                                                                                             |
   | functions              | -> (args) {} ¦ Sum = -> (a, b) { a + b }                                                                  |                                                                                                             |
   | <<                     | yielder                                                                                                   |                                                                                                             |
   |                        | enum_for                                                                                                  |                                                                                                             |
   |                        | to_enum                                                                                                   |                                                                                                             |
   | dup                    |                                                                                                           |                                                                                                             |
   |------------------------+-----------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------|
** Concepts
*** Iterator
    - is a method
    - it start and finish in the same call
*** Methods
**** Methods chaining
     creates a new object at it chains
     #+begin_src ruby
     puts animals.select {¦n¦ n[0] < 'M' }.map(&:upcase).join(", ")
     #+end_src
*** Enumerator
    - is an object
    - chaining
    - block based
    - method attachment (enum_for)
    - un-overriding of methods in Enumerable
    - maintain state
    - is an enumerable object
    - can add enumerability to objects
    - can stop and resume collection cycling
** Instructions
*** Rbenv
    rbenv global 2.3.0 && rbenv rehash
*** misc
    - $! → Exception: The exception object passed to raise.
    - $@ → Array: The stack backtrace generated by the last exception.
    - $& → String : The string matched (following a successful pattern match). This variable is local to the current scope.
* Toolings
  https://rubular.com
* Videos
  https://www.youtube.com/watch?v=hnGVFzZ0DuI - "300x faster ruby" - Dana Sherson
* Tests
** RSpec
** Unit
