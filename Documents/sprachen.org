#+TILE: Programming Languages - Study Annotations

* Inhaltsverzeichnis
  :PROPERTIES:
  :TOC:      :include all :depth 2 :ignore this
  :END:
:CONTENTS:
- [[#golang][Golang]]
  - [[#fortschritt][Fortschritt]]
  - [[#projekts][Projekts]]
  - [[#buchs][Buchs]]
  - [[#features][Features]]
  - [[#terms][Terms]]
  - [[#read-later][Read later]]
- [[#shell-scripts][Shell Scripts]]
  - [[#gnu-bash][GNU Bash]]
  - [[#others][Others]]
  - [[#posix][Posix]]
- [[#yaml][Yaml]]
  - [[#trais][trais]]
  - [[#resources][resources]]
- [[#emacs-lisp][Emacs Lisp]]
  - [[#progresso][Progresso]]
- [[#common-lisp][Common Lisp]]
  - [[#progresso][Progresso]]
  - [[#features][Features]]
- [[#terms][Terms]]
  - [[#search-traversal][Search Traversal]]
- [[#german][German]]
  - [[#fortschritt][Fortschritt]]
- [[#books][books]]
:END:

* Golang
** Fortschritt
*** Buch
    | Buch                    | Capt    | @                                    | late | revision |
    |-------------------------+---------+--------------------------------------+------+----------|
    | Go Programming Language | Methods | 6.2. Methods with a Pointer Receiver |      |          |
    |                         |         |                                      |      |          |

*** LDC
    | Source Code | folder          | file      | @ |
    |-------------+-----------------+-----------+---|
    | consul      |                 |           |   |
    | go          | src/archive/tar | common.go |   |
** Projekts
** Buchs
** Features
*** mutex
    #+begin_src go emacs-lisp :tangle yes
    sync.Mutex
    #+end_src
*** collective
    #+begin_src go
    strings.Map
    #+end_src
*** standary library
    #+begin_src go
    // end of line
    io.EOF

    #+end_src
*** functions
    - reference type
    - function values are not comparable.

    #+begin_src go
    // assign f to nil function
    var f func(int) int

    // assign var to a function
    func square(n int) int { return n * n }
    f =  square
    fmt.Println(f(3)) // "9"

    // can compare function to nil but not another function
    if f != nil { ... }

    // recursion in go is fast

    // lambda/anonymous function
    strings.Map(func(r rune) rune { return r + 1 }, "HAL-9000")


    // function that returns a lambda
    func squares() func() int {
	    var x int
	    return func() int {
		    x++
		    return x * x
	    }
    }
    func main() {
	    f := squares()
	    fmt.Println(f()) // "1"
	    fmt.Println(f()) // "4"
	    fmt.Println(f())
	    fmt.Println(f())
    }

    // Defer
    var mu sync.Mutex
    var m = make(map[string]int)

    func lookup(key string) int {
	    mu.Lock()
	    defer mu.Unlock()
	    return m[key]
    }
    #+end_src
*** print
    #+begin_src go
    Printf("%#v\n", w) // # display values in a form similar to Go synVtax.
    #+end_src
*** make
    #+begin_src go
    make([]T, len)
    make([]T, len, cap) // same as make([]T, cap)[:len]
    #+end_src
*** type
    #+begin_src go
    func (c Clear) String() string { // associates Clear to String
	    ...
    }

    #+end_src
*** variables
    #+begin_src go
    var x
    a int = 1
    a := 1
    #+end_src
*** const
*** doc comment
    Extensive doc comments are often place d in a file of their own, convent ion ally cal le d doc.go
*** pointers
    #+Begin_Src go

    func main() {
	    x = 1
	    ,*p = x
	    Printf(&p) // address of x
    }
    #+end_src
** Terms
   - runes: single characthers

** Read later
* Shell Scripts
** GNU Bash
*** Features
**** read
**** shift
     shift: shift cli args to next right
**** <<<
     here-string, give a pre-made string of text to a program
**** >&2
**** shopt
**** options
***** --init-file
      use alternative init file
***** -c
      run command and arguments
**** man
     - bash-builtins: describe bash built in features
**** >
     echo 'asd' > temp  | create a file or overwrite existent one
**** >>
     echo 'asd' >> temp | create a file or append to end of existent one
**** << EOF > OEF
     here documents
**** <<<
     here-string
*** Tips
    #+begin_src shell-script
    #  get word after $char in string $var
    ${var##*char}

    # return s
    ${var%sub}

    # variable inline assignment
    var=$(test && echo "A" || echo "B")

    # variable inline assignment numeric    |
    (( a = b==5 ? c : d )) or let a=b==5?c:d;

    # return arguments of function as array |
    $@
						 |                                       |

    #+end_src

*** Resources
    - http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html#toc6

    - https://bash.cyberciti.biz/guide/Main_Page

    - https://wiki.bash-hackers.org

    - https://explainshell.com/
**** Bash Articles
     https://wiki.bash-hackers.org/syntax/arrays

     https://phoxis.org/2010/03/14/read-multiple-arg-bash-script/

     https://likegeeks.com/linux-command-line-tricks/

     https://linuxize.com/post/bash-while-loop/

     https://www.linuxjournal.com/content/return-values-bash-functions

     https://natelandau.com/bash-scripting-utilities/

**** Bash Quick Tutorial
     #+BEGIN_SRC shell-script
     # Check if string contains a sub-string.
     if [[ "$var" == *sub_string* ]]; then
	 printf '%s\n' "sub_string is in var."
     fi

     # Inverse (substring not in string).
     if [[ "$var" != *sub_string* ]]; then
	 printf '%s\n' "sub_string is not in var."
     fi

     # This works for arrays too!
     if [[ "${arr[*]}" == *sub_string* ]]; then
	 printf '%s\n' "sub_string is in array."
     fi

     # Check if string starts with sub-string.
     if [[ "$var" == sub_string* ]]; then
	 printf '%s\n' "var starts with sub_string."
     fi

     # Inverse (var doesn't start with sub_string).
     if [[ "$var" != sub_string* ]]; then
	 printf '%s\n' "var does not start with sub_string."
     fi

     # Check if string ends with sub-string.
     if [[ "$var" == *sub_string ]]; then
	 printf '%s\n' "var ends with sub_string."
     fi

     # Inverse (var doesn't start with sub_string).
     if [[ "$var" != *sub_string ]]; then
	 printf '%s\n' "var does not end with sub_string."
     fi

     # Variables
     Assign and access a variable using a variable.

     hello_world="test"

     # Create the variable name.
     var1="world"
     var2="hello_${var1}"

     # Print the value of the variable name stored in 'hello_$var1'.
     printf '%s\n' "${!var2}"

     # Loop over a range of numbers.
     # Loop from 0-100 (no variable support).
     for i in {0..100}; do
	 printf '%s\n' "$i"
     done

     # Loop over a variable range of numbers.

     # Don't use seq.

     # Loop from 0-VAR.
     VAR=50
     for ((i=0;i<=VAR;i++)); do
	 printf '%s\n' "$i"
     done

     # Loop over an array.

     arr=(apples oranges tomatoes)

     # Just elements.
     for element in "${arr[@]}"; do
	 printf '%s\n' "$element"
     done

     # Loop over an array with an index.

     arr=(apples oranges tomatoes)

     # Elements and index.
     for i in "${!arr[@]}"; do
	 printf '%s\n' "${arr[$i]}"
     done

     # Alternative method.
     for ((i=0;i<${#arr[@]};i++)); do
	 printf '%s\n' "${arr[$i]}"
     done

     # Loop over the contents of a file.

     while read -r line; do
	 printf '%s\n' "$line"
     done < "file"

     # Loop over files and directories.

     # Don’t use ls.

     # Greedy example.
     for file in *; do
	 printf '%s\n' "$file"
     done

     # PNG files in dir.
     for file in ~/Pictures/*.png; do
	 printf '%s\n' "$file"
     done

     # Iterate over directories.
     for dir in ~/Downloads/*/; do
	 printf '%s\n' "$dir"
     done

     # Iterate recursively.
     shopt -s globstar
     for file in ~/Pictures/**/*; do
	 printf '%s\n' "$file"
     done
     shopt -u globstar

     # File handling
     # Read a file to a string.

     # Alternative to the cat command.

     file_data="$(<"file")"

     # Read a file to an array (by line).

     # Alternative to the cat command.

     # Bash <4
     IFS=$'\n' read -d "" -ra file_data < "file"

     # Bash 4+
     mapfile -t file_data < "file"

     # Split a string on a delimiter. string="1,2,3"
     # To multiple variables.
     IFS=, read -r var1 var2 var3 <<< "$string"

     # To an array.
     IFSA=, read -ra vars <<< "$string"

     # Create an empty file.

     # Alternative to touch.

     # Shortest.
     > file
     :> file

     # Longer alternatives:
     echo -n > file
     printf '' > file

     # Arithmetic
     # Simpler syntax to set variables.

     # Simple math
     ((var=1+2))

     # Decrement/Increment variable
     ((var++))
     ((var--))
     ((var+=1))
     ((var-=1))

     # Using variables
     ((var=var2*arr[2]))

     # Ternary tests.

     # Set the value of var to var2 if var2 is greater than var.
     # var: variable to set.
     # var2>var: Condition to test.
     # ?var2: If the test succeeds.
     # :var: If the test fails.
     ((var=var2>var?var2:var))

     # Shorter for loop syntax.

     # Tiny C Style.
     for((;i++<10;)){ echo "$i";}

	# Undocumented method.
	for i in {1..10};{ echo "$i";}

		 # Expansion.
		 for i in {1..10}; do echo "$i"; done

		 # C Style.
		 for((i=0;i<=10;i++)); do echo "$i"; done

		 # Shorter infinite loops.

		 # Normal method
		 while :; do echo hi; done

		 # Shorter
		 for((;;)){ echo hi;}

		     # Shorter function declaration.

		     # Normal method
		     f(){ echo hi;}

		     # Using a subshell
		     f()(echo hi)

		     # Using arithmetic
		     # You can use this to assign integer values.
		     # Example: f a=1
		     #          f a++
		     f()(($1))

		     # Using tests, loops etc.
		     # NOTE: You can also use ‘while’, ‘until’, ‘case’, ‘(())’, ‘[[]]’.
		     f()if true; then echo "$1"; fi
		     f()for i in "$@"; do echo "$i"; done

		     Shorter if syntax.

		     # One line
		     # Note: The 3rd statement may run when the 1st is true
		     [[ "$var" == hello ]] && echo hi || echo bye
		     [[ "$var" == hello ]] && { echo hi; echo there; } || echo bye

		     # Multi line (no else, single statement)
		     # Note: The exit status may not be the same as with an if statement
		     [[ "$var" == hello ]] && \
			 echo hi

		     # Multi line (no else)
		     [[ "$var" == hello ]] && {
			 echo hi
			 # ...
		     }

		     # Simpler case statement to set variable.

		     # We can use the : builtin to avoid repeating variable= in a case statement. The $_ variable stores the last argument of the last successful command. : always succeeds so we can abuse it to store the variable value.

		     # Example snippet from Neofetch.
		     case "$(uname)" in
			 "Linux" | "GNU"*)
			     : "Linux"
			     ;;

			 ,*"BSD" | "DragonFly" | "Bitrig")
			     : "BSD"
			     ;;

			 "CYGWIN"* | "MSYS"* | "MINGW"*)
			     : "Windows"
			     ;;

			 ,*)
			     printf '%s\n' "Unknown OS detected, aborting..." >&2
			     exit 1
			     ;;
		     esac

		     # Finally, set the variable.
		     os="$_"

		     #     Internal Variables

		     #     NOTE: This list does not include every internal variable (You can help by adding a missing entry!).

		     #     For a complete list, see: http://tldp.org/LDP/abs/html/internalvariables.html
		     # Get the location to the bash binary.

		     "$BASH"

		     # Get the version of the current running bash process.

		     # As a string.
		     "$BASH_VERSION"

		     # As an array.
		     "${BASH_VERSINFO[@]}"

		     # Open the user's preferred text editor.

		     "$EDITOR" "$file"

		     # NOTE: This variable may be empty, set a fallback value.
		     "${EDITOR:-vi}" "$file"

		     Get the name of the current function.

		     # Current function.
		     "${FUNCNAME[0]}"

		     # Parent function.
		     "${FUNCNAME[1]}"

		     # So on and so forth.
		     "${FUNCNAME[2]}"
		     "${FUNCNAME[3]}"

		     # All functions including parents.
		     "${FUNCNAME[@]}"

		     Get the host-name of the system.

		     "$HOSTNAME"

		     # NOTE: This variable may be empty.
		     # Optionally set a fallback to the hostname command.
		     "${HOSTNAME:-$(hostname)}"

		     # Get the architecture of the Operating System.

		     "$HOSTTYPE"

		     # Get the name of the Operating System / Kernel.

		     # This can be used to add conditional support for different Operating Systems without needing to call uname.

		     "$OSTYPE"

		     # Get the current working directory.

		     # This is an alternative to the pwd built-in.

		     "$PWD"

		     # Get the number of seconds the script has been running.

		     # Check if a program is in the user's PATH.

		     # There are 3 ways to do this and you can use either of
		     # these in the same way.
		     type -p executable_name &>/dev/null
		     hash executable_name &>/dev/null
		     command -v executable_name &>/dev/null

		     # As a test.
		     if type -p executable_name &>/dev/null; then
			 # Program is in PATH.
		     fi

		     # Inverse.
		     if ! type -p executable_name &>/dev/null; then
			 # Program is not in PATH.
		     fi

		     # Example (Exit early if program isn't installed).
		     if ! type -p convert &>/dev/null; then
			 printf '%s\n' "error: convert isn't installed, exiting..."
			 exit 1
		     fi

		     "$SECONDS"

		     # Bypass shell aliases.

		     # alias
		     ls

		     # command
		     # shellcheck disable=SC1001
		     \ls

		     # Bypass shell functions.

		     # function
		     ls

		     # command
		     command ls
     #+END_SRC
** Others
*** Fish
*** Zsh
*** TCSH
** Posix
*** Shell Commands
    |         |                                                                 |
    |---------+-----------------------------------------------------------------|
    | sudo !! | run last command as sudo                                        |
    | xargs   |                                                                 |
    | set -e  | -e  Exit immediately if a command exits with a non-zero status. |
* Yaml
** trais
*** pair = key: value
*** | =  pipe
*** > = pipe
*** indentaion = new objects
*** - = list
*** # = commentary
*** --- = multi archive
*** {{ var }} = use variables
*** quotes
     "barri go ta" or
     barri go ta
** resources
   https://yamllint.com
* Emacs Lisp
** Progresso
*** Livros
    | Livros           | Capitulo | em | tarde | revisao |
    |------------------+----------+----+-------+---------|
    | ANSI Common Lisp |          |    |       |         |
    |                  |          |    |       |         |

*** LDC
    | Source Code | folder | file | @ |
    |-------------+--------+------+---|
    | sbcl        |        |      |   |
    | asdf        |        |      |   |
    | alexandria  |        |      |   |
* Common Lisp
** Progresso
*** Livros
    | Livros           | Capitulo      | em | tarde | revisao |
    |------------------+---------------+----+-------+---------|
    | ANSI Common Lisp | 4.4 Sequences |    |       |         |
    |                  |               |    |       |         |

*** LDC
    | Source Code | folder | file | @ |
    |-------------+--------+------+---|
    | sbcl        |        |      |   |
    | asdf        |        |      |   |
    | alexandria  |        |      |   |
** Features
*** array
**** eg
     #+begin_src lisp
     (setf *print-array* t) ;; display form

     (setf arr (make-array '(2 3) : initial-element nil)) ;; make
     (aref arr 0 0) ;; retrieve
     (setf (aref arr 0 0) 'b) ;; replace
     #2a((b nil nil) (nil nil nil))
     (vector "a" 'b 3)
     #+end_src
**** annnotaion
     - multiple dimensions
     - zero indexed
     - one-dimensional array is also called a vector

*** lists
**** list
**** dotted (proper) list
     - is either nil, or a cons whose cdr is a proper list
     - dot notation
     - separated by a period
**** assoc lists (alist)
     - mapping
     - are slow
     - good for prototyping
     - assoc retrieves the pair associated with a given key else nil
     - assoc-if
*** conditionals
**** let
**** cond
**** when
**** unless
*** comparable
**** equal
**** eql
**** nth
**** sort
     - destructive
*** Misc
**** member
**** member-if
**** every
**** some
**** keywords (:test)
*** Short Notations
**** #'
**** '
**** `(,)
**** '()
*** Predicates
**** evenp
**** oddp
**** consp
**** atom
*** Sets
**** union
**** intersection
**** set-difference
**** adjoin
**** member
*** Sequences
**** length
**** subseq
**** reverse
* Terms
** Search Traversal
   - depth-first traversal
   - breadth-first traversal
* German
** Fortschritt
    | Buch                        | kapitel | @                           | @later | revision |
    |-----------------------------+---------+-----------------------------+--------+----------|
    | The Art of Unix programming |         | The Lessons of Unix History |        |          |
* books
  Designing Data Intensive Apps
