#+TILE: Lisp - Study Annotations

* Inhaltsverzeichnis
  :PROPERTIES:
  :TOC:      :include all :depth 2 :ignore this
  :END:
:CONTENTS:
- [[#golang][Golang]]
  - [[#fortschritt][Fortschritt]]
  - [[#projekts][Projekts]]
  - [[#buchs][Buchs]]
  - [[#terms][terms]]
  - [[#read-later][Read later]]
- [[#ruby][Ruby]]
  - [[#fortschritt][Fortschritt]]
  - [[#features][Features]]
  - [[#concepts][Concepts]]
  - [[#instructions][Instructions]]
- [[#shell-scripts][Shell Scripts]]
  - [[#gnu-bash][GNU Bash]]
  - [[#others][Others]]
  - [[#posix][Posix]]
- [[#yaml][Yaml]]
  - [[#trais][trais]]
  - [[#resources][resources]]
- [[#emacs-lisp][Emacs Lisp]]
  - [[#progresso][Progresso]]
- [[#common-lisp][Common Lisp]]
  - [[#progresso][Progresso]]
  - [[#features][Features]]
- [[#guile][Guile]]
  - [[#progresso][Progresso]]
- [[#german][German]]
  - [[#fortschritt][Fortschritt]]
:END:

* Golang
** Fortschritt
*** Buch
    | Buch | Capitulo | em | tarde | revisao |
    |------+----------+----+-------+---------|
    | a    |          |    |       |         |

*** LDC
    | Source Code | folder | file | @ |
    |-------------+--------+------+---|
    | golang      |        |      |   |
** Projekts
** Buchs
** terms
   - runes: single characthers
** Read later
* Ruby
** Fortschritt
*** Buch
    | Books                                                     | Capitulo                                       | em                                                       | tarde                          | revisao |
    |-----------------------------------------------------------+------------------------------------------------+----------------------------------------------------------+--------------------------------+---------|
    | Practical Object-Oriented Design                          | Designing Classes with a Single Responsibility | 2.2.3 Determining If a Class Has a Single Responsibility |                                |         |
    | Closure in Ruby                                           |                                                |                                                          |                                |         |
    | Design Patterns in Ruby                                   | Strategy                                       |                                                          |                                |         |
    | The Well Grounded Rubyist                                 | 12  File and I/O operations                    |                                                          |                                |         |
    | Beginning Rails 6                                         | Getting Something Running                      | Creating the Article Model                               |                                |         |
    | Pragmatic Build Awesome Command-Line Applications in Ruby |                                                |                                                          |                                |         |
    | Eloquent Ruby                                             | Chapter 8. Embrace Dynamic Typing              | Shorter Programs, But Not the Way You Think              | Spec: A Plethora of Assertions |         |
*** SLOC
    | Source Code | folder          | file       | @ |
    |-------------+-----------------+------------+---|
    | ruby        | lib/bundler/cli | install.rb |   |
    | rails       |                 |            |   |
** Features
*** Ruby
**** Features
***** dig
***** fetch
***** tap
***** Quoting
      %char{text}
      #+begin_src ruby
      a = %q(a b c d)

      b = %Q(a b c)
      #+end_src
***** heredocs
      #+begin_src ruby
      <<EOL

      EOL

      <<EOL.to_i * 10
      EOL

      <<'EOL'
      EOL

      <<-EOL
      EOL

      <<~EOL
      EOL

      [1,2, <<EO asdasd EO]

      a(false, <<EO asd... EO)
      #+end_src
***** proc
      #+begin_src ruby

      #+end_src
***** do end as param
      #+begin_src ruby
      x = (do  1 + 2 end)
      x = (do 'a' + 'b' end).join(',')
      #+end_src
***** array
      #+begin_src ruby
      a = [1, ["a", "b"], 4]
      arr[1][0]
      [1,2][0]
      arr.dig(3,0) value_at, a[2,3] = ..
      a[2..3]
      a.slice()
      a.[]=(0, "first")
      a.[](2)
      a = %w(a b c)
      a= %W({a} b c)
      x.to_ary
      x.to_arr
      Array()
      def string.to_arr
      end
      a.unshift(0)
      a.push(1,2,3)
      a << 5
      a.pop
      a.shift
      a.concat
      a.replace([1,2,3])
      a.flatten
      a.reverse
      a.join(" , ")
      a = *
      a.uniq
      a.compact
      a.size
      a.empty
      a.include?
      a.first
      a.last
      a.sample
      a.count(1)
      #+end_src
      [[file:path]]
***** date/time
      #+begin_src ruby
      require 'date'
      d = date.today

      require 'time'
      t = time.zxcz
      #+end_src
***** lambda
      #+begin_src ruby
      l = -> { xx; aa }
      l = lambda do
	yield xx
      end
      #+end_src
***** rescue
      #+begin_src ruby
      begin
	puts 'I am before the raise.'
	raise 'An error has occured.'
	puts 'I am after the raise.'
      rescue
	puts 'I am rescued.'
      end
      #+end_src
***** hash
      #+begin_src ruby
      h = Hash.new
      h = { one: 1, :two => 2 }
      h = Hash[1, "one", 2, "two"]
      h["1"] = 1
      h.[]=("New York", "NY")
      h.store("New York", "NY")
      a.update(b)
      a.merge(b)
      h.select {k,vk > 1 } !
      h.reject {  k,v  k > 1 } !
      h.reject! {  k,v  k > 1 }
      h = { street: "127th Street", apt: nil }.compact !
      h = { street: "127th Street", apt: nil }.compact!
      h.invert
      h.clear
      h = {...}.replace({...})
      h.key?
      h.empty?
      #+end_src
***** range
      #+begin_src ruby
      r = Range.new(1,100)
      r = Range.new(1,100, true)
      r =  1..99(inclusive) r = 1...199(exclusive)
      r.cover? 2
      r.include? 3
      #+end_src
***** sets
      #+begin_src ruby
      s = Set.new(array)
      s = Set.new(names) {name name.upcase }
      s << 5
      s.add 5
      s.delete(1)
      s.intersection|&| x
      s.union x
      s + x
      s.difference x
      s - x
      s ^ x
      s.merge [2]
      s.subset? b
      s.superset? b
      s.proper_subset? x
      s.proper_superset? x
      #+end_src
***** gsub
      Returns a copy of str with all occurrences of pattern substituted for the second argument.                                                                                                                                                                                                                                                                                                                              |
***** find
      #+begin_src ruby
      a.find { ¦n¦ n > 5 }
      a.find { ¦n¦ n > 5 }
      a.find_all
      a.select
      a.reject
      a.map
      #+end_src
***** map
      #+begin_src ruby
      a.map { |x| x.uppercase}
      a.map! { |x| x.uppercase}
      #+end_src
***** each_slice
      #+begin_src ruby
      animals.each_slice(2).map do |predator, prey|
      #+end_src
***** lazy
      #+begin_src ruby
      (1..Float::INFINITY).lazy.select {|n| n % 3 == 0 }
      #+end_src
***** with_index
      #+begin_src ruby
      ['a'..'z').map.with_index {|letter,i| [letter, i] } // Output: [["a", 0], ["b", 1], etc.]
      my_enum.take(5).force // actual result rather than lazy enumerator
      #+end_src
***** enum_for
      #+begin_src ruby
      e = names.enum_for(:inject, "Names: ")
      #+end_src
***** more

      | drop_while             | a.drop_while { true }                                                                                                                                                                                                                                                                                                                                                                                                   |                                                                                                             |
      | take_while             | a.take_while { true }                                                                                                                                                                                                                                                                                                                                                                                                   |                                                                                                             |
      | find_all               | a.find_all ¦ a.select                                                                                                                                                                                                                                                                                                                                                                                                   |                                                                                                             |
      | reject                 | a.reject { ¦i¦ i > 4 } ¦ a.reject! { ¦i¦ i > 4 }                                                                                                                                                                                                                                                                                                                                                                        |                                                                                                             |
      | select                 |                                                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                                             |
      | grep                   | a.grep(//o//) ¦ a.grep(String) ¦ a.grep(50..100) ¦                                                                                                                                                                                                                                                                                                                                                                        |                                                                                                             |
      | group_by               | a.group_by { ¦s¦ s.size }                                                                                                                                                                                                                                                                                                                                                                                               |                                                                                                             |
      | match                  | //n//.match(s)                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                             |
      | String                 | 'C'.size ¦ each_byte ¦ each_line ¦ each_codepoint ¦ each_char ¦ s.bytes ¦                                                                                                                                                                                                                                                                                                                                               |                                                                                                             |
      | min/min_by             | a.min { ¦a,b¦ a.size <=> b.size } ¦  a.min { ¦lang¦ lang.size } ¦ state_hash.min_by { ¦name, abbr¦ name }                                                                                                                                                                                                                                                                                                               |                                                                                                             |
      | max/max_by             |                                                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                                             |
      | minmax/minmax_by       | a.minmax ¦ a.minmax_by { ¦lang¦ lang.size }                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                             |
      | reverse_each           | [1,2,3].reverse_each { ¦e¦ puts e * 10 }                                                                                                                                                                                                                                                                                                                                                                                |                                                                                                             |
      | with_index             | letters.each.with_index {¦(key,value),i¦ puts i }                                                                                                                                                                                                                                                                                                                                                                       |                                                                                                             |
      | each_index             | names.each.with_index(1) { ¦pres, i¦ p i }                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                             |
      | each_slice             |                                                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                                             |
      | each_cons              |                                                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                                             |
      | slice_before           | a.slice_before(\/=/).to_a ¦ (1..10).slice_before { ¦num¦ num % 2 == 0 }.to_a ¦                                                                                                                                                                                                                                                                                                                                          |                                                                                                             |
      | slice_after            |                                                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                                             |
      | slice_when             | a.slice_when { ¦i,j¦ i == j }.to_a                                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                             |
      | inject/reduce          | [1,2,3,4].inject(:+)                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                             |
      | cycle                  |                                                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                                             |
      | map                    | names.map { ¦name¦ name.upcase } ¦  x = 5.times.map { Apple.new(rand(100..900)) }                                                                                                                                                                                                                                                                                                                                       |                                                                                                             |
      | map!                   |                                                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                                             |
      | symbol-argument blocks | names.map(&:upcase)                                                                                                                                                                                                                                                                                                                                                                                                     |                                                                                                             |
      | <=>                    | Apple#<=> ¦ Apple.sort { ¦a,b¦ a.brand <=> b.brand } ¦                                                                                                                                                                                                                                                                                                                                                                  | implementing a spaceship test method is enough to sort a class, or use a block to sort, or even override it |
      | comparable             | Apple#<=> ¦                                                                                                                                                                                                                                                                                                                                                                                                             | include comparable                                                                                          |
      | clamp                  |                                                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                                             |
      | between                |                                                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                                             |
      | functions              | -> (args) {} ¦ Sum = -> (a, b) { a + b }                                                                                                                                                                                                                                                                                                                                                                                |                                                                                                             |
      | <<                     | yielder                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                             |
      |                        | enum_for                                                                                                                                                                                                                                                                                                                                                                                                                |                                                                                                             |
      |                        | to_enum                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                             |
      | dup                    |                                                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                                             |
      |------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------|
*** Rails
**** Models
     | what   | $ | ...         |
     |--------+---+-------------|
     | Models |   | Camel-Cased |
     |        |   |             |

**** Cli
***** Database
      | what     | how                                                                    | desc                                              |
      |----------+------------------------------------------------------------------------+---------------------------------------------------|
      | database | –d or --database=                                                      | use the database management system of your choice |
      |          | db:create:all                                                          |                                                   |
      |          | db:create                                                              |                                                   |
      |          | dbconsole                                                              |                                                   |
      |          | db:migrate                                                             |                                                   |
      |          | new <name>                                                             |                                                   |
      | models   | generate model <Name>                                                  |                                                   |
      |          | destroy controller articles                                            |                                                   |
      |          | rails destroy model Artile                                             |                                                   |
      |          | rails db:rollback                                                      |                                                   |
      |          | generate scaffold Article title:string body:text published_at:datetime |                                                   |

***** Models
      | what     | how                                                                    | desc                                              |
      |----------+------------------------------------------------------------------------+---------------------------------------------------|
      | models   | generate model <Name>                                                  |                                                   |
      |          | destroy controller articles                                            |                                                   |
      |          | rails destroy model Artile                                             |                                                   |
      |          | rails db:rollback                                                      |                                                   |
      |          | generate scaffold Article title:string body:text published_at:datetime |                                                   |
***** ENV
      |   |                      |   |
      |---+----------------------+---|
      |   | RAILS_ENV=production |   |

** Concepts
*** Iterator
    - is a method
    - it start and finish in the same call
*** Methods
**** Methods chaining
     creates a new object at it chains
     #+begin_src ruby
     puts animals.select {¦n¦ n[0] < 'M' }.map(&:upcase).join(", ")
     #+end_src
*** Enumerator
    - is an object
    - chaining
    - block based
    - method attachment (enum_for)
    - un-overriding of methods in Enumerable
    - maintain state
    - is an enumerable object
    - can add enumerability to objects
    - can stop and resume collection cycling
** Instructions
*** Rbenv
    rbenv global 2.3.0 && rbenv rehash
* Shell Scripts
** GNU Bash
*** Features
**** read
**** shift
     shift: shift cli args to next right
**** <<<
     here-string, give a pre-made string of text to a program
**** >&2
**** shopt
**** options
***** --init-file
      use alternative init file
***** -c
      run command and arguments
**** man
     - bash-builtins: describe bash built in features
**** >
     echo 'asd' > temp  | create a file or overwrite existent one
**** >>
     echo 'asd' >> temp | create a file or append to end of existent one
**** << EOF > OEF
     here documents
**** <<<
     here-string
*** Tips
    #+begin_src shell-script
    #  get word after $char in string $var
    ${var##*char}

    # return s
    ${var%sub}

    # variable inline assignment
    var=$(test && echo "A" || echo "B")

    # variable inline assignment numeric    |
    (( a = b==5 ? c : d )) or let a=b==5?c:d;

    # return arguments of function as array |
    $@
						 |                                       |

    #+end_src

*** Resources
    - http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html#toc6

    - https://bash.cyberciti.biz/guide/Main_Page

    - https://wiki.bash-hackers.org

    - https://explainshell.com/
**** Bash Articles
     https://wiki.bash-hackers.org/syntax/arrays

     https://phoxis.org/2010/03/14/read-multiple-arg-bash-script/

     https://likegeeks.com/linux-command-line-tricks/

     https://linuxize.com/post/bash-while-loop/

     https://www.linuxjournal.com/content/return-values-bash-functions

     https://natelandau.com/bash-scripting-utilities/

**** Bash Quick Tutorial
     #+BEGIN_SRC shell-script
     # Check if string contains a sub-string.
     if [[ "$var" == *sub_string* ]]; then
	 printf '%s\n' "sub_string is in var."
     fi

     # Inverse (substring not in string).
     if [[ "$var" != *sub_string* ]]; then
	 printf '%s\n' "sub_string is not in var."
     fi

     # This works for arrays too!
     if [[ "${arr[*]}" == *sub_string* ]]; then
	 printf '%s\n' "sub_string is in array."
     fi

     # Check if string starts with sub-string.
     if [[ "$var" == sub_string* ]]; then
	 printf '%s\n' "var starts with sub_string."
     fi

     # Inverse (var doesn't start with sub_string).
     if [[ "$var" != sub_string* ]]; then
	 printf '%s\n' "var does not start with sub_string."
     fi

     # Check if string ends with sub-string.
     if [[ "$var" == *sub_string ]]; then
	 printf '%s\n' "var ends with sub_string."
     fi

     # Inverse (var doesn't start with sub_string).
     if [[ "$var" != *sub_string ]]; then
	 printf '%s\n' "var does not end with sub_string."
     fi

     # Variables
     Assign and access a variable using a variable.

     hello_world="test"

     # Create the variable name.
     var1="world"
     var2="hello_${var1}"

     # Print the value of the variable name stored in 'hello_$var1'.
     printf '%s\n' "${!var2}"

     # Loop over a range of numbers.
     # Loop from 0-100 (no variable support).
     for i in {0..100}; do
	 printf '%s\n' "$i"
     done

     # Loop over a variable range of numbers.

     # Don't use seq.

     # Loop from 0-VAR.
     VAR=50
     for ((i=0;i<=VAR;i++)); do
	 printf '%s\n' "$i"
     done

     # Loop over an array.

     arr=(apples oranges tomatoes)

     # Just elements.
     for element in "${arr[@]}"; do
	 printf '%s\n' "$element"
     done

     # Loop over an array with an index.

     arr=(apples oranges tomatoes)

     # Elements and index.
     for i in "${!arr[@]}"; do
	 printf '%s\n' "${arr[$i]}"
     done

     # Alternative method.
     for ((i=0;i<${#arr[@]};i++)); do
	 printf '%s\n' "${arr[$i]}"
     done

     # Loop over the contents of a file.

     while read -r line; do
	 printf '%s\n' "$line"
     done < "file"

     # Loop over files and directories.

     # Don’t use ls.

     # Greedy example.
     for file in *; do
	 printf '%s\n' "$file"
     done

     # PNG files in dir.
     for file in ~/Pictures/*.png; do
	 printf '%s\n' "$file"
     done

     # Iterate over directories.
     for dir in ~/Downloads/*/; do
	 printf '%s\n' "$dir"
     done

     # Iterate recursively.
     shopt -s globstar
     for file in ~/Pictures/**/*; do
	 printf '%s\n' "$file"
     done
     shopt -u globstar

     # File handling
     # Read a file to a string.

     # Alternative to the cat command.

     file_data="$(<"file")"

     # Read a file to an array (by line).

     # Alternative to the cat command.

     # Bash <4
     IFS=$'\n' read -d "" -ra file_data < "file"

     # Bash 4+
     mapfile -t file_data < "file"

     # Split a string on a delimiter. string="1,2,3"
     # To multiple variables.
     IFS=, read -r var1 var2 var3 <<< "$string"

     # To an array.
     IFSA=, read -ra vars <<< "$string"

     # Create an empty file.

     # Alternative to touch.

     # Shortest.
     > file
     :> file

     # Longer alternatives:
     echo -n > file
     printf '' > file

     # Arithmetic
     # Simpler syntax to set variables.

     # Simple math
     ((var=1+2))

     # Decrement/Increment variable
     ((var++))
     ((var--))
     ((var+=1))
     ((var-=1))

     # Using variables
     ((var=var2*arr[2]))

     # Ternary tests.

     # Set the value of var to var2 if var2 is greater than var.
     # var: variable to set.
     # var2>var: Condition to test.
     # ?var2: If the test succeeds.
     # :var: If the test fails.
     ((var=var2>var?var2:var))

     # Shorter for loop syntax.

     # Tiny C Style.
     for((;i++<10;)){ echo "$i";}

	# Undocumented method.
	for i in {1..10};{ echo "$i";}

		 # Expansion.
		 for i in {1..10}; do echo "$i"; done

		 # C Style.
		 for((i=0;i<=10;i++)); do echo "$i"; done

		 # Shorter infinite loops.

		 # Normal method
		 while :; do echo hi; done

		 # Shorter
		 for((;;)){ echo hi;}

		     # Shorter function declaration.

		     # Normal method
		     f(){ echo hi;}

		     # Using a subshell
		     f()(echo hi)

		     # Using arithmetic
		     # You can use this to assign integer values.
		     # Example: f a=1
		     #          f a++
		     f()(($1))

		     # Using tests, loops etc.
		     # NOTE: You can also use ‘while’, ‘until’, ‘case’, ‘(())’, ‘[[]]’.
		     f()if true; then echo "$1"; fi
		     f()for i in "$@"; do echo "$i"; done

		     Shorter if syntax.

		     # One line
		     # Note: The 3rd statement may run when the 1st is true
		     [[ "$var" == hello ]] && echo hi || echo bye
		     [[ "$var" == hello ]] && { echo hi; echo there; } || echo bye

		     # Multi line (no else, single statement)
		     # Note: The exit status may not be the same as with an if statement
		     [[ "$var" == hello ]] && \
			 echo hi

		     # Multi line (no else)
		     [[ "$var" == hello ]] && {
			 echo hi
			 # ...
		     }

		     # Simpler case statement to set variable.

		     # We can use the : builtin to avoid repeating variable= in a case statement. The $_ variable stores the last argument of the last successful command. : always succeeds so we can abuse it to store the variable value.

		     # Example snippet from Neofetch.
		     case "$(uname)" in
			 "Linux" | "GNU"*)
			     : "Linux"
			     ;;

			 ,*"BSD" | "DragonFly" | "Bitrig")
			     : "BSD"
			     ;;

			 "CYGWIN"* | "MSYS"* | "MINGW"*)
			     : "Windows"
			     ;;

			 ,*)
			     printf '%s\n' "Unknown OS detected, aborting..." >&2
			     exit 1
			     ;;
		     esac

		     # Finally, set the variable.
		     os="$_"

		     #     Internal Variables

		     #     NOTE: This list does not include every internal variable (You can help by adding a missing entry!).

		     #     For a complete list, see: http://tldp.org/LDP/abs/html/internalvariables.html
		     # Get the location to the bash binary.

		     "$BASH"

		     # Get the version of the current running bash process.

		     # As a string.
		     "$BASH_VERSION"

		     # As an array.
		     "${BASH_VERSINFO[@]}"

		     # Open the user's preferred text editor.

		     "$EDITOR" "$file"

		     # NOTE: This variable may be empty, set a fallback value.
		     "${EDITOR:-vi}" "$file"

		     Get the name of the current function.

		     # Current function.
		     "${FUNCNAME[0]}"

		     # Parent function.
		     "${FUNCNAME[1]}"

		     # So on and so forth.
		     "${FUNCNAME[2]}"
		     "${FUNCNAME[3]}"

		     # All functions including parents.
		     "${FUNCNAME[@]}"

		     Get the host-name of the system.

		     "$HOSTNAME"

		     # NOTE: This variable may be empty.
		     # Optionally set a fallback to the hostname command.
		     "${HOSTNAME:-$(hostname)}"

		     # Get the architecture of the Operating System.

		     "$HOSTTYPE"

		     # Get the name of the Operating System / Kernel.

		     # This can be used to add conditional support for different Operating Systems without needing to call uname.

		     "$OSTYPE"

		     # Get the current working directory.

		     # This is an alternative to the pwd built-in.

		     "$PWD"

		     # Get the number of seconds the script has been running.

		     # Check if a program is in the user's PATH.

		     # There are 3 ways to do this and you can use either of
		     # these in the same way.
		     type -p executable_name &>/dev/null
		     hash executable_name &>/dev/null
		     command -v executable_name &>/dev/null

		     # As a test.
		     if type -p executable_name &>/dev/null; then
			 # Program is in PATH.
		     fi

		     # Inverse.
		     if ! type -p executable_name &>/dev/null; then
			 # Program is not in PATH.
		     fi

		     # Example (Exit early if program isn't installed).
		     if ! type -p convert &>/dev/null; then
			 printf '%s\n' "error: convert isn't installed, exiting..."
			 exit 1
		     fi

		     "$SECONDS"

		     # Bypass shell aliases.

		     # alias
		     ls

		     # command
		     # shellcheck disable=SC1001
		     \ls

		     # Bypass shell functions.

		     # function
		     ls

		     # command
		     command ls
     #+END_SRC
** Others
*** Fish
*** Zsh
*** TCSH
** Posix
*** Shell Commands
    |         |                                                                 |
    |---------+-----------------------------------------------------------------|
    | sudo !! | run last command as sudo                                        |
    | xargs   |                                                                 |
    | set -e  | -e  Exit immediately if a command exits with a non-zero status. |
* Yaml
** trais
*** pair = key: value
*** | =  pipe
*** > = pipe
*** indentaion = new objects
*** - = list
*** # = commentary
*** --- = multi archive
*** {{ var }} = use variables
*** quotes
     "barri go ta" or
     barri go ta
** resources
   https://yamllint.com
* Emacs Lisp
** Progresso
*** Livros
    | Livros           | Capitulo | em | tarde | revisao |
    |------------------+----------+----+-------+---------|
    | ANSI Common Lisp |          |    |       |         |
    |                  |          |    |       |         |

*** LDC
    | Source Code | folder | file | @ |
    |-------------+--------+------+---|
    | sbcl        |        |      |   |
    | asdf        |        |      |   |
    | alexandria  |        |      |   |
* Common Lisp
** Progresso
*** Livros
    | Livros           | Capitulo | em | tarde | revisao |
    |------------------+----------+----+-------+---------|
    | ANSI Common Lisp |          |    |       |         |
    |                  |          |    |       |         |

*** LDC
    | Source Code | folder | file | @ |
    |-------------+--------+------+---|
    | sbcl        |        |      |   |
    | asdf        |        |      |   |
    | alexandria  |        |      |   |
** Features
*** array
**** eg
     #+begin_src lisp
     (setf *print-array* t) ;; display form

     (setf arr (make-array '(2 3) : initial-element nil)) ;; make
     (aref arr 0 0) ;; retrieve
     (setf (aref arr 0 0) 'b) ;; replace
     #2a((b nil nil) (nil nil nil))
     (vector "a" 'b 3)
     #+end_src
**** annnotaion
     - multiple dimensions
     - zero indexed
     - one-dimensional array is also called a vector

*** lists
**** list
**** dotted (proper) list
     - is either nil, or a cons whose cdr is a proper list
     - dot notation
     - separated by a period
**** assoc lists (alist)
     - mapping
     - are slow
     - good for prototyping
     - assoc retrieves the pair associated with a given key else nil
     - assoc-if
*** conditionals
**** let
**** cond
**** when
**** unless
*** comparable
**** equal
**** eql
**** nth
**** sort
     - destructive
*** Misc
**** member
**** member-if
**** every
**** some
**** keywords (:test)
*** Short Notations
**** #'
**** '
**** `(,)
**** '()
*** Predicates
**** evenp
**** oddp
**** consp
**** atom
*** Sets
**** union
**** intersection
**** set-difference
**** adjoin
**** member
*** Sequences
**** length
**** subseq
**** reverse
* Guile
** Progresso
*** Livros
    | Livros           | Capitulo | em | tarde | revisao |
    |------------------+----------+----+-------+---------|
    | ANSI Common Lisp |          |    |       |         |
    |                  |          |    |       |         |

*** LDC
    | Source Code | folder | file | @ |
    |-------------+--------+------+---|
    | sbcl        |        |      |   |
    | asdf        |        |      |   |
    | alexandria  |        |      |   |
* German
** Fortschritt
    | Buch                        | kapitel | @                           | @later | revision |
    |-----------------------------+---------+-----------------------------+--------+----------|
    | The Art of Unix programming |         | The Lessons of Unix History |        |          |
