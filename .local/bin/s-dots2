#!/usr/bin/env python3

from pathlib import Path
import sys
from tkinter import W

# require "find"

# TODO: Remove unused early symlinked dotfiles
# TODO: backup files before removing and symlinkin
# TODO: Clone repo fixed commit
# TODO: Read-only symlinks


class Dots:
    """Mirror Lar files in $HOME."""

    # HOME = Path.home
    # attr_reader :home,

    def __init__(self, root):
        self.root = Path(root)  # if root
        self.target_link = {}

    def ignored_ones(self):
        """ignore these dotfiles"""

        dots = self.root.joinpath(".dotsignore")

        with open(dots) as file:
            files = file.read()

        files = files.splitlines()
        files.append(".dotsignore")  # ignore itself too, ofc!

        files = list(set(files))
        return files

    #   def children?(current):
    #     dotignored.map { |x| current.to_path.include? root.join(x).to_path }.any?

    #   def all():
    #     files = []
    #     folders = []

    #     Find.find(root) do |current|
    #       current = Pathname.new current

    #       next if current.to_path.include? ".git" # ignore the .git folder!
    #       next if children? current
    #       next if current == root # ????

    #       current.file? ? files << current : folders << current

    #     { folders: folders, files: files } # folders will not be a symlink

    #   # transform origin file absolute path with home as its root instead
    #   # /a/b/c.tar --> /home/b/c.tar
    #   def to_home(this):
    #     origin = this.to_path
    #     homey = HOME.to_path.concat("/")
    #     result = origin.gsub(root.to_path, homey)

    #     Pathname.new result

    #   # Create only the folders, if those do not exist
    #   def make_folders():
    #     all[:folders].each do |fld|
    #       folder = to_home fld
    #       next if folder.exist?

    #       puts folder
    #       folder.mkdir

    #   def files_mirrored():
    #     raise "not implemented"

    #   def feed_target_link():
    #     all[:files].each do |target|
    #       symlink_name = to_home target
    #       target_link.store(target, symlink_name)

    #   # Move file from home to a /home/backup/{file}
    #   # or delete it if the file it is pointing does not exist
    #   def backup_this(this):
    #     warn "WARNING: #{this} found! Deleting/Moving it."
    #     this.delete if this.exist? # TODO: if file exist back/delete up it

    #   def backup_files():
    #     target_link.each do |target, link_name|
    #       puts "#{target} ❯ #{link_name}"
    #       backup_this link_name

    #   def symlink_files():
    #     target_link.each do |target, link_name|
    #       puts "#{target} ❯ #{link_name}"
    #       link_name.make_symlink target # As enumerator yielding folder to symlink

    def run(self):
        self.ignored_ones()


#     feed_target_link
#     make_folders
#     backup_files
#     symlink_files


def main() -> int:
    print(Dots(sys.argv[1]).ignored_ones())


if __name__ == "__main__":
    sys.exit(main())
