#! /usr/bin/env elixir

defmodule Dots do
  defp ignored(path) do
    ignored_exist?(path)
    |> case do
      {:ok, files} ->
        File.stream!(files)
        |> Enum.map(&String.trim(&1))
        |> Enum.concat([".dotsignore"])
        |> Enum.map(&Path.join(path, &1))
        |> MapSet.new()

      {:error, nil} ->
        []
    end
  end

  defp ignored_exist?(path) do
    path = Path.join(path, ".dotsignore")
    if File.exists?(path), do: {:ok, path}, else: {:error, nil}
  end

  defp ignore_me?(path, item) do
    ignored(path)
    |> Enum.any?(&String.starts_with?(item, &1))
  end

  def ls_r(path) do
    cond do
      File.regular?(path) ->
        [path]

      File.dir?(path) ->
        File.ls!(path)
        |> Enum.map(&Path.join(path, &1))
        |> Enum.map(&ls_r/1)
        |> Enum.concat()

      true ->
        []
    end
  end

  def walk(path) do
    items = ls_r(path)

    for item <- items do
      unless ignore_me?(path, item) do
        target = item
        link_name = to_home(item, path)

        make_folder(link_name)
        link_file(target, link_name)
        # IO.puts("#{target} -> #{link_name}")
      end
    end
  end

  def to_home(item, path) do
    # /data/dots/.config/mpd/mpd.conf to $HOME/.config/mpd/mpd.conf
    String.replace(item, path, System.user_home())
  end

  def make_folder(link_name) do
    link_dir = Path.dirname(link_name)

    unless File.exists?(link_dir) do
      IO.puts("Directory #{link_dir} not found! Creating it.")
      File.mkdir_p!(link_dir)
    end
  end

  def link_file(target, link_name) do
    unless File.exists?(link_name) do
      IO.puts("Symlink #{link_name} not found! Linking it.")
      File.ln_s!(target, link_name)
    end
  end

  def deploy(path) do
    IO.puts("deploying")
    walk(path)
  end

  def pretend(path) do
    IO.puts("pretend-mode")
    IO.inspect(path)
  end

  def info(path) do
    IO.puts("root: #{path}")
  end
end

defmodule Cli do
  def parse(args) do
    args
    |> OptionParser.parse(
      switches: [deploy: :string, pretend: :string, help: :boolean],
      aliases: [D: :deploy, P: :pretend, H: :help]
    )
    |> run()
  end

  def run(args_parsed) do
    args_parsed
    |> case do
      {options, _remaining_args, _errors} ->
        case options do
          [deploy: path] ->
            path = Path.dirname(IO.chardata_to_string(path))
            Dots.deploy(path)

          [pretend: path] ->
            path = Path.dirname(IO.chardata_to_string(path))
            Dots.pretend(path)

          _ ->
            IO.puts("Usage: dots [options]
    -d, --deploy                    deploy dotfiles symlinking
    -p, --pretend                   mimic symlinking deployment")
        end
    end
  end
end

Cli.parse(System.argv())
