#!/usr/bin/env ruby
# frozen_string_literal: true

# Main entry point
class Main
  attr_reader :manager

  def initialize
    @manager = SoundManager.new.info
  end

  def toggle
    manager.toggle
  end

  def up
    manager.up
  end

  def down
    manager.down
  end

  def info
    manager.to_s
  end
end

# Find available sound manager
class SoundManager
  def which?(executable)
    File.executable?(executable.to_s)
  end

  def all
    [Pactl.new, Amixer.new, Mixer.new]
  end

  # Sound Manager Information
  def info
    all.first { |manager| which?(manager::EXEC) }
  end
end

# pactl - Control a running PulseAudio sound server
class Pactl
  EXEC = '/usr/bin/pactl'
  STEP = 3

  def toggle
    "#{EXEC} set-sink-mute #{sink} toggle"
  end

  def up
    "#{EXEC} set-sink-volume #{sink} +#{STEP}%"
  end

  def down
    "#{EXEC} set-sink-volume #{sink} -#{STEP}%"
  end

  def to_s
    <<~INFO
      exec: #{EXEC}
      sink: #{sink}

      -- spec --

      #{`pactl info`}
    INFO
  end

  private

  def sink
    '@DEFAULT_SINK@'
  end

  def sink_legacy
    require 'English'

    output = `set -eu; pactl list sinks`
    raise('pipeline failed') unless $CHILD_STATUS.success?

    case ENV['LANG']
    when 'pt_BR.UTF-8'
      dest = 'Destino'
      state = 'Estado'
    when 'en_US.UTF-8'
      dest = 'Sink'
      state = 'State'
    end

    # sink id is the first letter in the string returned
    output.split("#{dest} #").find do |sink|
      sink if sink.include? "#{state}: RUNNING"
    end.split(state).first.strip
  end
end

# bsd mixer
class Mixer
  EXEC = '/sbin/mixer'

  def mixer
    {
      name: 'mixer',
      toggle: '',
      updown: "mixer vol #{states[state]}#{STEP}"
    }
  end

  def toggle
    [mixer[:name], mixer[:toggle]].join(' ')
  end

  def updown
    [mixer[:name], mixer[:updown]].join(' ')
  end
end

# Command-line ALSA mixer
class Amixer
  EXEC = '/usr/bin/amixer'

  def amixer
    {
      name: 'amixer',
      toggle: '-q sset Master toggle',
      updown: "set Master #{STEP}%#{states[state]}"
    }
  end

  def toggle
    [amixer[:name], amixer[:toggle]].join(' ')
  end

  def updown
    [amixer[:name], amixer[:updown]].join(' ')
  end
end

# hail to the new king
class Pipewire
  def info
    {
      name: 'pw-cli',
      args: "s #{pipe_id} Props",
      toggle: '{ mute: false, channelVolumes: [ 1.5, 1.5 ] }',
      updown: '{ mute: false, channelVolumes: [ 1.5, 1.5 ] }'
    }
  end

  def id; end

  def toggle
    [info[:name], info[:toggle]].join(' ')
  end

  def updown
    [info[:name], info[:updown]].join(' ')
  end
end

module Cli
  require 'optparse'

  def self.options
    main = Main.new

    OptionParser.new do |opts|
      opts.banner = 'Usage: volume [options]'

      opts.on('-u', '--up', 'Increase volume') do |_v|
        system main.up
      end

      opts.on('-d', '--down', 'Decrease volume') do |_v|
        system main.down
      end

      opts.on('-t', '--toggle', 'Toggle volume') do |_v|
        system main.toggle
      end

      opts.on('-i', '--info', 'Volume manager information') do |_v|
        puts main.info
      end
    end
  end
end

Cli.options.parse! ['--help'] if ARGV.empty?
Cli.options.parse!
