#!/usr/bin/env ruby
# coding: utf-8
# frozen_string_literal: true

# Description: An opitionated dotfile deployer base on guix home and nix homemanager.

# Features:
# - a dotsignore at the repository root behaves just like git's one,
#   prevents symlinking undesired files/folders to $HOME.
# - Folders are not symlinked but created.

# TODO: Remove faulty early symlinked dotfiles.
# TODO: Accept git commit sha as source to symlink deployment.
# TODO: Read-only symlinks.
# TODO: dotsignore to accept hash-like folder. eg: .config{foo,bar,meh,forevis}

require 'pathname'
require 'find'
require 'optparse'

# Mirrors, by symlinking, a dotfiles repository to $HOME.
class Dots
  HOME = Pathname.new Dir.home

  attr_reader :root, :home, :target_link

  def initialize(root)
    @root = Pathname.new(root) if root
    @target_link = {}.tap { |f| all_items[:files].each { |t| f.store(t, to_home(t)) } }
  end

  # ignore these dotfiles
  def dotignored
    dots = root.join('.dotsignore').read.split "\n"
    dots.append '.dotsignore' # ignore itself too, ofc!
    dots.append '.git' if root.join('.git').exist? # ignore the .git folder.
    dots.uniq # users may not notice duplicated dotfiles.
  end

  # is ITEM included in root folder?
  def children?(item)
    dotignored.map { |x| item.to_path.include? root.join(x).to_path }.any?
  end

  # organize listed items in .dotsignore as pathname
  def all_items
    { files: [], folders: [] }.tap do |x|
      Find.find(root) do |item|
        item = Pathname.new item

        next if item == root # skip the root folder itself
        next if children? item

        if item.file?
          x[:files] << item
        else
          x[:folders] << item
        end
      end
    end
  end

  # transform  stringfied origin item's root absolute path to home
  # /a/b/c.tar --> /home/b/c.tar
  def to_home(item)
    item_path = item.to_path
    home_path = HOME.to_path.concat('/') # / is needed to crop enterily item_path root path

    Pathname.new item_path.gsub(root.to_path, home_path)
  end

  # do not symlink but create top folders of files if it does not exist
  def make_folders
    all_items[:folders].each do |folder|
      homey_folder = to_home folder
      next if homey_folder.exist?

      puts "Creating folder: #{homey_folder}"
      homey_folder.mkdir
    end
  end

  def files_mirrored
    raise 'not implemented'
  end

  # Move file from home to a /home/backup/{file}
  # or delete it if the file it is pointing does not exist
  def backup_item(item)
    warn "WARNING: #{item} found! Deleting/Moving it."
    item.delete if item.exist? # TODO: if file exist back/delete up it
  end

  def backup_files
    target_link.each do |target, link_name|
      puts "#{target} ❯ #{link_name}"
      backup_item link_name
    end
  end

  def symlink_files
    target_link.each do |target, link_name|
      puts "#{target} ❯ #{link_name}"
      link_name.make_symlink target # As enumerator yielding folder to symlink
    end
  end

  def deploy
    make_folders
    backup_files
    symlink_files
  end

  def info
    puts @root
  end

  def dryrun
    p target_link
  end
end

def cli
  OptionParser.new do |opts|
    main = Dots.new(ARGV[1])
    opts.banner = 'Usage: dots [options]'

    opts.on('-s', '--symlink', 'deploy dotfiles symlinking') do
      main.deploy
    end

    opts.on('-d', '--dry-run', 'mimic symlinking deployment') do
      main.dryrun
    end

    opts.on('-i', '--info', 'general information of internals commands') do
      main.info
    end
  end
end

cli.parse! ['--help'] if ARGV.empty?
cli.parse!
