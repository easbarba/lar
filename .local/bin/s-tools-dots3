#! /usr/bin/env elixir

defmodule Dots do
  defp ignored(path) do
    ignored_exist?(path)
    |> case do
      {:ok, files} ->
        File.stream!(files)
        |> Enum.map(&String.trim(&1))
        |> Enum.concat([".dotsignore"])
        |> Enum.map(&Path.join(path, &1))
        |> MapSet.new()

      {:error, nil} ->
        []
    end
  end

  defp ignored_exist?(path) do
    path = Path.join(path, ".dotsignore")
    if File.exists?(path), do: {:ok, path}, else: {:error, nil}
  end

  defp ignore_me?(path, item) do
    ignored(path)
    |> Enum.any?(&String.starts_with?(item, &1))
  end

  def ls_r(path) do
    cond do
      File.regular?(path) ->
        [path]

      File.dir?(path) ->
        File.ls!(path)
        |> Enum.map(&Path.join(path, &1))
        |> Enum.map(&ls_r/1)
        |> Enum.concat()

      true ->
        []
    end
  end

  def walk(path) do
    items = ls_r(path)

    for item <- items do
      unless ignore_me?(path, item) do
        IO.puts(item)
      end
    end
  end

  def deploy(path) do
    IO.puts("deploying")
    walk(path)
  end

  def pretend(path) do
    IO.puts("pretend-mode")
    IO.inspect(path)
  end

  def info(path) do
    IO.puts("root: #{path}")
  end

  def help(errors) do
    IO.puts("Heeeeeeeeeelp #{errors}")
  end
end

defmodule Cli do
  def parse(args) do
    args
    |> OptionParser.parse(
      switches: [deploy: :string, pretend: :string, help: :boolean],
      aliases: [D: :deploy, P: :pretend, H: :help]
    )
    |> run()
  end

  def run(args_parsed) do
    args_parsed
    |> case do
      {options, _remaining_args, [] = errors} ->
        case options do
          [deploy: path] ->
            path = Path.dirname(IO.chardata_to_string(path))
            Dots.deploy(path)

          [pretend: path] ->
            path = Path.dirname(IO.chardata_to_string(path))
            Dots.pretend(path)

          _ ->
            Dots.help(errors)
        end
    end
  end
end

Cli.parse(System.argv())
